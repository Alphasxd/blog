---
layout: post
title: ğŸ§© LeetCode
categories: codetips
---

# Based on the Top 100 Liked Questions

### å“ˆå¸Œ

<details markdown="1">
<summary>1. ä¸¤æ•°ä¹‹å’Œï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target  çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

> å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆ

```golang
func twoSum(nums []int, target int) []int {
    m := make(map[int]int, len(nums))
    for i, num := range nums {
        if j, ok := m[target-num]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```
> éå†åŸå§‹æ•°ç»„å°†**æ•°ç»„å…ƒç´ **ä½œä¸º keyï¼Œ**å…ƒç´ ç´¢å¼•**ä½œä¸º value å­˜å…¥ map å³å¯ï¼›

> Tipsï¼šæŠŠè¿”å›ç»“æœå†™åœ¨æ–°å¢ kv ä¹‹å‰

</details>

<details markdown="1">
<summary>49. å­—æ¯å¼‚ä½è¯åˆ†ç»„ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¯·ä½ å°† å­—æ¯å¼‚ä½è¯ ç»„åˆåœ¨ä¸€èµ·ã€‚å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç»“æœåˆ—è¡¨

```golang
func groupAnagrams(strs []string) [][]string {
    m := map[string][]string{}
    for _, str := range strs {
        s := []byte(str)
        sort.Slice(s, func(i, j int) bool {
            return s[i] < s[j]
        })
        sortedStr := string(s)
        m[sortedStr] = append(m[sortedStr], str)
    }
    // è½¬ä¸ºäºŒç»´åˆ‡ç‰‡
    ans := make([][]string, 0, len(m))
    for _, v := range m {
        ans = append(ans, v)
    }
    return ans
}
```

> å­—ç¬¦ä¸² `->` å­—ç¬¦åˆ‡ç‰‡ `->` æ’åº `->` å­—ç¬¦ä¸² `->` map

</details>

<details markdown="1">
<summary>128. æœ€é•¿è¿ç»­åºåˆ—ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦ã€‚

> è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n)

```golang
func longestConsecutive(nums []int) int {
    m := make(map[int]bool)
    for _, num := range nums {
        m[num] = true
    }
    longest := 0
    for num := range m {
        // ç¡®ä¿ num æ˜¯è¿ç»­åºåˆ—çš„èµ·ç‚¹
        if m[num-1] {
            continue
        }
        length := 1
        for m[num+1] {
            num++
            length++
        }
        if length > longest {
            longest = length
        }
    }
    return longest
}
```

> ç”¨ map å½“ä½œé›†åˆï¼Œéå†æ•°ç»„å¯»æ‰¾åˆ°â€œè¿ç»­åºåˆ—çš„èµ·ç‚¹â€ï¼Œç„¶åæ›´æ–°æœ€é•¿è¿ç»­åºåˆ—é•¿åº¦

</details>

### åŒæŒ‡é’ˆ

<details markdown="1">
<summary>283. ç§»åŠ¨é›¶ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåº

> å¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œ

```golang
func moveZeroes(nums []int)  {
    for i, j := 0, 0; j < len(nums); j++ {
        if nums[j] != 0 {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
}
```

> i, j éƒ½ä» 0 å¼€å§‹ï¼Œj è´Ÿè´£éå†æ•°ç»„ï¼Œi è´Ÿè´£è®°å½•é 0 å…ƒç´ çš„ä½ç½®ï¼Œj é‡åˆ°é 0 å…ƒç´ å°±äº¤æ¢ i å’Œ j çš„å€¼

</details>

<details markdown="1">
<summary>88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸¤ä¸ªéé€’å‡é¡ºåºæ’åˆ—çš„æ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œæœ‰ä¸¤ä¸ªæ•´æ•° m å’Œ nï¼Œåˆ†åˆ«è¡¨ç¤º nums1 å’Œ nums2 ä¸­çš„å…ƒç´ æ•°ç›®ã€‚è¯·ä½ å°† nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿åˆå¹¶åçš„æ•°ç»„åŒæ ·æŒ‰éé€’å‡é¡ºåºæ’åˆ—ã€‚

> nums1 çš„åˆå§‹é•¿åº¦ä¸º m + nï¼Œå…¶ä¸­å‰ m ä¸ªå…ƒç´ è¡¨ç¤ºåº”åˆå¹¶çš„å…ƒç´ ï¼Œå n ä¸ªå…ƒç´ ä¸º 0 ï¼Œåº”å¿½ç•¥ã€‚nums2 çš„é•¿åº¦ä¸º n ã€‚

```golang
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p := m-1, n-1, m+n-1
    for p2 >= 0 { // nums2 è¿˜æœ‰å…ƒç´ æœªå¤„ç†
        if p1 >= 0 && nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
}
```

> å€’åºåŒæŒ‡é’ˆï¼Œp1 æŒ‡å‘ nums1 æœ«å°¾ï¼Œp2 æŒ‡å‘ nums2 æœ«å°¾ï¼Œp æŒ‡å‘ nums1 çš„æœ«å°¾ï¼Œæ¯æ¬¡æ¯”è¾ƒ p1 å’Œ p2 çš„å€¼ï¼Œå°†è¾ƒå¤§çš„å€¼æ”¾åˆ° nums1 çš„æœ«å°¾ï¼Œé¿å…è¦†ç›– nums1 çš„å€¼

</details>

<details markdown="1">
<summary>11. ç››æ°´æœ€å¤šçš„å®¹å™¨ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ heightã€‚æœ‰ n æ¡å‚çº¿ï¼Œç¬¬ i æ¡çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯ (i, 0) å’Œ (i, height[i])ã€‚

> æ‰¾å‡ºå…¶ä¸­çš„ä¸¤æ¡çº¿ï¼Œä½¿å¾—å®ƒä»¬ä¸ x è½´å…±åŒæ„æˆçš„å®¹å™¨å¯ä»¥å®¹çº³æœ€å¤šçš„æ°´ã€‚è¿”å›å®¹å™¨å¯ä»¥å‚¨å­˜çš„æœ€å¤§æ°´é‡ã€‚

```golang
func maxArea(height []int) int {
    ans := 0
    i, j := 0, len(height)-1
    for i < j {
        if height[i] < height[j] {
            ans = max(ans, height[i]*(j-i))
            i++
        } else {
            ans = max(ans, height[j]*(j-i))
            j--
        }
    }
    return ans
}
```
> åŒæŒ‡é’ˆï¼Œi æŒ‡å‘é¦–ï¼Œj æŒ‡å‘å°¾ï¼Œæ¯æ¬¡ç§»åŠ¨ height å€¼è¾ƒå°çš„æŒ‡é’ˆï¼Œè®¡ç®—é¢ç§¯å¹¶æ›´æ–°æœ€å¤§é¢ç§¯ `Area = min(height[i], height[j]) * (j - i)`

> å¦‚æœç§»åŠ¨è¾ƒå¤§çš„é‚£ä¸ªæŒ‡é’ˆï¼Œä¸ä¼šæœ‰ä»»ä½•æ„ä¹‰ï¼Œå› ä¸ºæœ¨æ¡¶åŸç†ï¼Œå®¹å™¨çš„å®¹é‡åªä¼šæœ‰å˜å¾—æ›´å°çš„å¯èƒ½

</details>

<details markdown="1">
<summary>15. ä¸‰æ•°ä¹‹å’Œï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != k ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0 ã€‚è¯·ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

> ç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„

```golang
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    ans := make([][]int, 0)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        lo, hi := i+1, len(nums)-1
        for lo < hi {
            sum := nums[i] + nums[lo] + nums[hi]
            switch {
            case sum > 0:
                hi--
            case sum < 0:
                lo++
            default:
                ans = append(ans, []int{nums[i], nums[lo], nums[hi]})
                hi--
                lo++
                // å»é‡ï¼Œä¸èƒ½æœ‰é‡å¤çš„ä¸‰å…ƒç»„
                for lo < hi && nums[lo] == nums[lo-1] {
                    lo++
                }
                for lo < hi && nums[hi] == nums[hi+1] {
                    hi--
                }
            }
        }
    }
    return ans
}
```

> å…ˆæ’åºï¼Œç„¶åå›ºå®šä¸€ä¸ªæ•°ï¼ŒåŒæŒ‡é’ˆéå†å‰©ä½™æ•°ç»„ï¼Œæ³¨æ„å»é‡

</details>

<details markdown="1">
<summary>75. é¢œè‰²åˆ†ç±»ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªåŒ…å«çº¢è‰²ã€ç™½è‰²å’Œè“è‰²ã€å…± n ä¸ªå…ƒç´ çš„æ•°ç»„ nums ï¼ŒåŸåœ° å¯¹å®ƒä»¬è¿›è¡Œæ’åºï¼Œä½¿å¾—ç›¸åŒé¢œè‰²çš„å…ƒç´ ç›¸é‚»ï¼Œå¹¶æŒ‰ç…§çº¢è‰²ã€ç™½è‰²ã€è“è‰²é¡ºåºæ’åˆ—ã€‚æˆ‘ä»¬ä½¿ç”¨æ•´æ•° 0ã€ 1 å’Œ 2 åˆ†åˆ«è¡¨ç¤ºçº¢è‰²ã€ç™½è‰²å’Œè“è‰²ã€‚å¿…é¡»åœ¨ä¸ä½¿ç”¨åº“å†…ç½®çš„ sort å‡½æ•°çš„æƒ…å†µä¸‹è§£å†³è¿™ä¸ªé—®é¢˜

```golang
func sortColors(nums []int) {
    zero, two := 0, len(nums)-1
    // one ä»å·¦å¾€å³éå†ï¼Œé‡åˆ° 0 åˆ™ä¸ zero äº¤æ¢ï¼Œé‡åˆ° 2 åˆ™ä¸ two äº¤æ¢
    for one := 0; one <= two; {
        switch nums[one] {
        case 0:
            nums[zero], nums[one] = nums[one], nums[zero]
            zero++
            one++
        case 1:
            one++
        case 2:
            nums[one], nums[two] = nums[two], nums[one]
            two--
        }
    }
}
```

> ä¸‰æŒ‡é’ˆï¼Œzero æŒ‡å‘ 0 çš„æœ€å³è¾¹ç•Œï¼Œtwo æŒ‡å‘ 2 çš„æœ€å·¦è¾¹ç•Œï¼Œone éå†æ•°ç»„ï¼Œé‡åˆ° 0 å’Œ zero äº¤æ¢ï¼Œé‡åˆ° 2 å’Œ two äº¤æ¢

</details>

<details markdown="1">
<summary>31. ä¸‹ä¸€ä¸ªæ’åˆ—ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡º nums çš„ä¸‹ä¸€ä¸ªæ’åˆ—ã€‚å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ï¼Œåˆ™å°† nums é‡æ–°æ’åˆ—æˆæœ€å°çš„æ’åˆ—ï¼ˆå³å‡åºæ’åˆ—ï¼‰

```golang
func nextPermutation(nums []int) {
    if len(nums) < 2 {
        return
    }
    i, j, k := len(nums)-2, len(nums)-1, len(nums)-1
    for i >= 0 && nums[i] >= nums[j] {
        i--
        j--
    }
    if i >= 0 {
        for nums[i] >= nums[k] {
            k--
        }
        nums[i], nums[k] = nums[k], nums[i]
    }
    reverse(nums, j, len(nums)-1)
}
func reverse(nums []int, start, end int) {
    for start < end {
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}
```
> å¯ä»¥ç›´æ¥å°†å­—å…¸æ’åºç†è§£ä¸ºä¸€ä¸ªæ•´æ•°æ¯”è¾ƒå¤§å°çš„é—®é¢˜ï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ªæ¯”å½“å‰å¤§çš„æœ€å°çš„æ•´æ•°å³å¯

> ä»å³å¾€å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‡åºå¯¹ (i, j)ï¼Œå†ä»å³å¾€å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äº nums[i] çš„æ•°ï¼Œäº¤æ¢ i å’Œ kï¼Œæœ€åç¿»è½¬ j åˆ°æœ«å°¾çš„å…ƒç´ 

</details>

<details markdown="1">
<summary>287. å¯»æ‰¾é‡å¤æ•°ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªåŒ…å« n + 1 ä¸ªæ•´æ•°çš„æ•°ç»„ nums ï¼Œå…¶æ•°å­—éƒ½åœ¨ [1, n] èŒƒå›´å†…ï¼ˆåŒ…æ‹¬ 1 å’Œ nï¼‰ï¼Œå¯çŸ¥è‡³å°‘å­˜åœ¨ä¸€ä¸ªé‡å¤çš„æ•´æ•°ã€‚å‡è®¾ nums åªæœ‰ ä¸€ä¸ªé‡å¤çš„æ•´æ•° ï¼Œè¿”å› è¿™ä¸ªé‡å¤çš„æ•°

> å¿…é¡» ä¸ä¿®æ”¹ æ•°ç»„ nums ä¸”åªç”¨å¸¸é‡çº§ O(1) çš„é¢å¤–ç©ºé—´

```golang
func findDuplicate(nums []int) int {
    slow := nums[nums[0]]
    fast := nums[nums[nums[0]]]
    for slow != fast {
        slow = nums[slow]
        fast = nums[nums[fast]]
    }
    // slow ä» nums[0] å¼€å§‹ï¼Œfast ä»ç›¸é‡ç‚¹å¼€å§‹ï¼Œå†æ¬¡ç›¸é‡æ—¶å³ä¸ºé‡å¤å…ƒç´ 
    duplicate := nums[0]
    for duplicate != slow {
        duplicate = nums[duplicate]
        slow = nums[slow]
    }
    return duplicate
}
```

> å¿«æ…¢æŒ‡é’ˆï¼Œç±»ä¼¼äºåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ï¼Œæ‰¾åˆ°ç¯çš„å…¥å£

</details>

### æ»‘åŠ¨çª—å£

<details markdown="1">
<summary>3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ æœ€é•¿ å­ä¸² çš„é•¿åº¦

```golang
func lengthOfLongestSubstring(s string) int {
    m := make(map[rune]int)
    length, left := 0, 0
    // range s ä¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º rune æ•°ç»„
    for right, c := range s {
        if _, ok := m[c]; ok && m[c] >= left {
            // å­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œæ›´æ–°leftçš„å€¼
            left = m[c] + 1
        }
        // æ›´æ–°å­—ç¬¦æœ€åå‡ºç°çš„ä½ç½®
        m[c] = right
        if right-left+1 > length {
            length = right - left + 1
        }
    }
    return length
}
```

> ç”¨ map è®°å½•å­—ç¬¦å‡ºç°çš„ä½ç½®ï¼Œleft ä¸ºå­ä¸²èµ·å§‹ï¼Œright ä¸ºå­ä¸²ç»“æŸï¼Œé‡åˆ°é‡å¤å­—ç¬¦æ—¶æ›´æ–°å·¦æŒ‡é’ˆ left

</details>

<details markdown="1">
<summary>438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ pï¼Œæ‰¾åˆ° s ä¸­æ‰€æœ‰ p çš„ å¼‚ä½è¯ çš„å­ä¸²ï¼Œè¿”å›è¿™äº›å­ä¸²çš„èµ·å§‹ç´¢å¼•ã€‚ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚å¼‚ä½è¯ æŒ‡ç”±ç›¸åŒå­—æ¯é‡æ’åˆ—å½¢æˆçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ç›¸åŒçš„å­—ç¬¦ä¸²ï¼‰

```golang
func findAnagrams(s string, p string) []int {
    var res []int
    var cnt [26]int
    for _, c := range p {
        cnt[c-'a']++
    }
    left, right := 0, 0
    var window [26]int
    for right < len(s) {
        window[s[right]-'a']++
        for window[s[right]-'a'] > cnt[s[right]-'a'] {
            window[s[left]-'a']--
            left++
        }
        if right-left+1 == len(p) {
            res = append(res, left)
        }
        right++
    }
    return res
}
```

> ç”¨æ•°ç»„è®°å½• p ä¸­å­—ç¬¦å‡ºç°æ¬¡æ•°ï¼Œéå† sï¼Œæ¯æ¬¡ç§»åŠ¨çª—å£ï¼Œåˆ¤æ–­çª—å£å†…å­—ç¬¦å‡ºç°æ¬¡æ•°æ˜¯å¦å’Œ p ç›¸åŒ

</details>

### å­ä¸²

<details markdown="1">
<summary>560. å’Œä¸º K çš„å­æ•°ç»„ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å› è¯¥æ•°ç»„ä¸­å’Œä¸º k çš„å­æ•°ç»„çš„ä¸ªæ•° ã€‚å­æ•°ç»„æ˜¯æ•°ç»„ä¸­å…ƒç´ çš„è¿ç»­éç©ºåºåˆ—ã€‚

```golang
func subarraySum(nums []int, k int) int {
    cnt, preSum := 0, 0
    // key ä¸ºå‰ç¼€å’Œï¼Œvalue ä¸ºå‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°
    m := make(map[int]int)
    m[0] = 1
    for i := 0; i < len(nums); i++ {
        preSum += nums[i]
        if _, ok := m[preSum-k]; ok {
            cnt += m[preSum-k]
        }
        m[preSum]++
    }
    return cnt
}
```

> ç”¨ map è®°å½•å‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°ï¼Œéå†æ•°ç»„ï¼Œè®¡ç®—å‰ç¼€å’Œï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ preSum - k çš„å‰ç¼€å’Œ

</details>

### æ™®é€šæ•°ç»„

<details markdown="1">
<summary>53. æœ€å¤§å­æ•°ç»„å’Œï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚å­æ•°ç»„æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†

```golang
func maxSubArray(nums []int) int {
    var max, sum int
    for i, num := range nums {
        sum += num
        // å¦‚æœ sum å¤§äº max æˆ–è€…æ˜¯ç¬¬ä¸€æ¬¡éå†æ—¶
        if sum > max || i == 0 {
            max = sum
        }
        // èˆå¼ƒè¿‡å»ï¼Œé‡æ–°å¼€å§‹ï¼Œè´ªå¿ƒæ€æƒ³
        if sum < 0 {
            sum = 0
        }
    }
    return max
}
```

> ç”¨ sum è®°å½•å½“å‰å’Œï¼Œmax è®°å½•æœ€å¤§å’Œï¼Œéå†æ•°ç»„ï¼Œå¦‚æœ sum å°äº 0ï¼Œå°±ä»å½“å‰å…ƒç´ å¼€å§‹é‡æ–°è®¡ç®—

</details>

<details markdown="1">
<summary>152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­ä¹˜ç§¯æœ€å¤§çš„éç©ºè¿ç»­ å­æ•°ç»„ï¼ˆè¯¥å­æ•°ç»„ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰ï¼Œå¹¶è¿”å›è¯¥å­æ•°ç»„æ‰€å¯¹åº”çš„ä¹˜ç§¯ã€‚

```golang
func maxProduct(nums []int) int {
    product, res := 1, nums[0]
    for i := range len(nums) {
        product *= nums[i]
        res = max(res, product)
        if nums[i] == 0 {
            // é‡ç½® productï¼Œå³å½“å‰å­æ•°ç»„çš„ä¹˜ç§¯
            product = 1
        }
    }
    // ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡ä»å·¦åˆ°å³ï¼Œç¬¬äºŒæ¬¡ä»å³åˆ°å·¦
    product = 1
    for i := len(nums) - 1; i >= 0; i-- {
        product *= nums[i]
        res = max(res, product)
        if nums[i] == 0 {
            product = 1
        }
    }
    return res
}
```

> ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡ä»å·¦å¾€å³è®¡ç®—ä¹˜ç§¯ï¼Œç¬¬äºŒæ¬¡ä»å³å¾€å·¦è®¡ç®—ä¹˜ç§¯ï¼Œå–æœ€å¤§å€¼ï¼Œåº”å¯¹æœ‰å¥‡æ•°ä¸ªè´Ÿæ•°çš„æƒ…å†µ

</details>

<details markdown="1">
<summary>56. åˆå¹¶åŒºé—´ï¼ˆMediumï¼‰</summary>

> ä»¥æ•°ç»„ intervals è¡¨ç¤ºè‹¥å¹²ä¸ªåŒºé—´çš„é›†åˆï¼Œå…¶ä¸­å•ä¸ªåŒºé—´ä¸º intervals[i] = [starti, endi] ã€‚è¯·ä½ åˆå¹¶æ‰€æœ‰é‡å çš„åŒºé—´ï¼Œå¹¶è¿”å› ä¸€ä¸ªä¸é‡å çš„åŒºé—´æ•°ç»„ï¼Œè¯¥æ•°ç»„éœ€æ°å¥½è¦†ç›–è¾“å…¥ä¸­çš„æ‰€æœ‰åŒºé—´ ã€‚

```golang
func merge(intervals [][]int) [][]int {
    // æŒ‰æ¯ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹å‡åºæ’åº
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    res := [][]int{}
    prev := intervals[0]
    // éå†åŒºé—´ï¼Œä»ç¬¬äºŒä¸ªåŒºé—´å¼€å§‹
    for i := 1; i < len(intervals); i++ {
        if cur := intervals[i]; prev[1] < cur[0] {
            res = append(res, prev)
            prev = cur
        } else { // æœ‰é‡å ï¼Œæ›´æ–° prev çš„å³ç«¯ç‚¹ä¸ºä¸¤ä¸ªåŒºé—´çš„æœ€å¤§å€¼
            prev[1] = max(prev[1], cur[1])
        }
    }
    res = append(res, prev)
    return res
}
```

> å…ˆæ’åºï¼Œç„¶åéå†æ•°ç»„ï¼Œå¦‚æœå½“å‰åŒºé—´çš„å·¦è¾¹ç•Œå¤§äºå‰ä¸€ä¸ªåŒºé—´çš„å³è¾¹ç•Œï¼Œå°±æ·»åŠ åˆ°ç»“æœé›†ï¼Œå¦åˆ™æ›´æ–°å‰ä¸€ä¸ªåŒºé—´çš„å³è¾¹ç•Œï¼ˆå–æœ€å¤§å€¼ï¼‰

</details>

<details markdown="1">
<summary>189. è½®è½¬æ•°ç»„ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œå°†æ•°ç»„ä¸­çš„å…ƒç´ å‘å³è½®è½¬ k ä¸ªä½ç½®ï¼Œå…¶ä¸­ k æ˜¯éè´Ÿæ•°ã€‚

```golang
func rotate(nums []int, k int) {
    // å¯¹ k å–ä½™ï¼Œé¿å… k å¤§äºæ•°ç»„é•¿åº¦æ—¶å¤šä½™çš„åè½¬
    k %= len(nums)
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])
}
func reverse(nums []int) {
    // åªéœ€è¦åè½¬ä¸€åŠçš„æ•°ç»„ï¼Œj-i-1 æ˜¯ä¸ºäº†é¿å…å¥‡æ•°æ•°ç»„æ—¶ä¸­é—´çš„æ•°è¢«åè½¬ä¸¤æ¬¡
    for i, n := 0, len(nums); i < n/2; i++ {
        nums[i], nums[n-i-1] = nums[n-i-1], nums[i]
    }
}
```

> ä¸‰æ¬¡ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬ï¼Œå†ç¿»è½¬å‰ k ä¸ªå…ƒç´ ï¼Œæœ€åç¿»è½¬å n-k ä¸ªå…ƒç´ 

</details>

<details markdown="1">
<summary>238. é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ•°ç»„ answer ï¼Œå…¶ä¸­ answer[i] ç­‰äº nums ä¸­é™¤ nums[i] ä¹‹å¤–å…¶ä½™å„å…ƒç´ çš„ä¹˜ç§¯ ã€‚

```golang
func productExceptSelf(nums []int) []int {
    length := len(nums)
    ans := make([]int, length)
    product := 1
    for i := range ans {
        ans[i] = product
        // å°† ans[i] è®¾ä¸ºå·¦ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
        product *= nums[i]
    }
    product = 1
    for i := length - 1; i >= 0; i-- {
        // å°†ä¸Šä¸€æ­¥çš„ç»“æœä¹˜ä»¥å³ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯å³ä¸ºç­”æ¡ˆ
        ans[i] *= product
        // å°† ans[i] è®¾ä¸º ans[i] * å³ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
        product *= nums[i]
    }
    return ans
}
```

> å·¦ä¾§ä¹˜ç§¯ * å³ä¾§ä¹˜ç§¯

</details>

<details markdown="1">
<summary>41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°ï¼ˆHardï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­æ²¡æœ‰å‡ºç°çš„æœ€å°çš„æ­£æ•´æ•°ã€‚

`é›†åˆ`

```golang
func firstMissingPositive1(nums []int) int {
    set := make(map[int]struct{}, len(nums))
    for _, v := range nums {
        if v > 0 {
            set[v] = struct{}{}
        }
    }
    for i := 1; i <= len(nums); i++ {
        if _, ok := set[i]; !ok {
            return i
        }
    }
    return len(nums) + 1
}
```

> éå†æ•°ç»„ï¼Œå°†æ­£æ•°å­˜å…¥é›†åˆï¼Œå†éå† 1 åˆ° n+1ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åœ¨é›†åˆä¸­çš„æ­£æ•°

`åŸåœ°å“ˆå¸Œ`

```golang
func firstMissingPositive(nums []int) int {
    for _, v := range nums {
        for v > 0 && v <= len(nums) && nums[v-1] != v {
            nums[v-1], v = v, nums[v-1]
        }
    }
    for i := 1; i <= len(nums); i++ {
        if nums[i-1] != i {
            return i
        }
    }
    return len(nums) + 1
}
```

> è‡ªå®šä¹‰å“ˆå¸Œï¼Œå°†æ¯ä¸ªæ­£æ•°æ”¾åˆ°å¯¹åº”çš„ä½ç½®ï¼Œå†éå†æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åœ¨å¯¹åº”ä½ç½®çš„æ­£æ•°

</details>

### çŸ©é˜µ

<details markdown="1">
<summary>48. æ—‹è½¬å›¾åƒï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ª n Ã— n çš„äºŒç»´çŸ©é˜µ matrix è¡¨ç¤ºä¸€ä¸ªå›¾åƒã€‚è¯·ä½ å°†å›¾åƒé¡ºæ—¶é’ˆæ—‹è½¬ 90 åº¦ã€‚

```golang
func rotate(matrix [][]int) {
    n := len(matrix)
    // æ°´å¹³ç¿»è½¬
    for i := 0; i < n/2; i++ {
        matrix[i], matrix[n-i-1] = matrix[n-i-1], matrix[i]
    }
    // ä¸»å¯¹è§’çº¿ç¿»è½¬
    for i := 0; i < n; i++ {
        for j := 0; j < i; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}
```

> é¡ºæ—¶é’ˆæ—‹è½¬90åº¦ï¼š è½¬ç½® + æ°´å¹³ç¿»è½¬

> é€†æ—¶é’ˆæ—‹è½¬90åº¦ï¼š è½¬ç½® + å‚ç›´ç¿»è½¬

</details>

<details markdown="1">
<summary>240. æœç´¢äºŒç»´çŸ©é˜µ IIï¼ˆMediumï¼‰</summary>

> ç¼–å†™ä¸€ä¸ªé«˜æ•ˆçš„ç®—æ³•æ¥æœç´¢ m x n çŸ©é˜µ matrix ä¸­çš„ä¸€ä¸ªç›®æ ‡å€¼ target ã€‚è¯¥çŸ©é˜µå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼šæ¯è¡Œçš„å…ƒç´ ä»å·¦åˆ°å³å‡åºæ’åˆ—ã€‚æ¯åˆ—çš„å…ƒç´ ä»ä¸Šåˆ°ä¸‹å‡åºæ’åˆ—ã€‚

```golang
func searchMatrix(matrix [][]int, target int) bool {
    for _, r := range matrix {
        i := sort.SearchInts(r, target)
        if i < len(r) && r[i] == target {
            return true
        }
    }
    return false
}
```

> sort.SearchInts() è¿”å› target åœ¨ r ä¸­çš„ç´¢å¼•ï¼Œå¦‚æœæ‰¾åˆ°äº†å°±è¿”å› true

</details>

### é“¾è¡¨

<details markdown="1">
<summary>160. ç›¸äº¤é“¾è¡¨ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨ä¸å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å› null 

```golang
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}
```

> ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œå½“éå†åˆ°å°¾éƒ¨æ—¶ï¼ŒæŒ‡å‘å¦ä¸€ä¸ªé“¾è¡¨çš„å¤´éƒ¨ï¼Œæœ€ç»ˆä¼šåœ¨ç›¸äº¤èŠ‚ç‚¹ç›¸é‡

</details>

<details markdown="1">
<summary>206. åè½¬é“¾è¡¨ï¼ˆEasyï¼‰</summary>

> ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨

`å¤´æ’æ³•`

```golang
func reverseList(head *ListNode) *ListNode {
    dummy := &ListNode{}
    for head != nil {
        // è¾…åŠ©èŠ‚ç‚¹ï¼Œé˜²æ­¢æ–­é“¾
        next := head.Next
        // å¤´æ’æ³•
        head.Next = dummy.Next
        dummy.Next = head
        head = next
    }
    return dummy.Next
}
```

`åè½¬æŒ‡é’ˆ`
```golang
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    for head != nil {
        next := head.Next // next æŒ‡å‘ curr çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        head.Next = prev  // åè½¬ curr çš„æŒ‡é’ˆ
        prev = head       // prev æŒ‡å‘ curr
        head = next       // curr æŒ‡å‘ next
    }
    // prev æŒ‡å‘åè½¬åçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    return prev
}
```

</details>

<details markdown="1">
<summary>234. å›æ–‡é“¾è¡¨ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head (äº‹å®ä¸Šæ˜¯é¦–å…ƒç»“ç‚¹)ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› trueï¼›å¦åˆ™ï¼Œè¿”å› false

`è¾…åŠ©åˆ‡ç‰‡`

```golang
func isPalindrome(head *ListNode) bool {
    vals := []int{}
    for head != nil {
        vals = append(vals, head.Val)
        head = head.Next
    }
    // éå†åˆ‡ç‰‡çš„å‰åŠéƒ¨åˆ†ï¼Œå¦‚æœæœ‰ä¸ç›¸ç­‰çš„å€¼ï¼Œè¿”å› false
    for i, v := range vals[:len(vals)/2] {
        if v != vals[len(vals)-i-1] {
            return false
        }
    }
    return true
}
```

> éå†é“¾è¡¨ï¼Œå°†å€¼å­˜å…¥åˆ‡ç‰‡ï¼Œå†åˆ¤æ–­åˆ‡ç‰‡æ˜¯å¦ä¸ºå›æ–‡

`å¿«æ…¢æŒ‡é’ˆ`

```golang
func isPalindrome(head *ListNode) bool {
    var prev *ListNode
    slow, fast := head, head
    // å¿«æŒ‡é’ˆèµ°åˆ°é“¾è¡¨å°¾éƒ¨ï¼Œæ…¢æŒ‡é’ˆèµ°åˆ°é“¾è¡¨ä¸­é—´
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        // åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œå°†å‰åŠéƒ¨åˆ†é“¾è¡¨åè½¬
        next := slow.Next
        slow.Next = prev
        prev = slow
        slow = next
    }
    // head æŒ‡å‘å‰åŠéƒ¨åˆ†å·²ç»åè½¬çš„é¦–å…ƒç»“ç‚¹
    head = prev
    // prev å†æŒ‡å›slowï¼Œç”¨äºå†æ¬¡æ¢å¤å‰åŠéƒ¨åˆ†çš„é“¾è¡¨
    prev = slow
    // å¦‚æœ fast ä¸ä¸º nil è¯´æ˜è·³å‡ºå¾ªç¯çš„æ—¶å€™ fast.Next ä¸º nilï¼Œå³é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°
    // å°† slow è·³è¿‡ä¸­é—´èŠ‚ç‚¹ï¼ŒæŒ‡å‘ååŠéƒ¨åˆ†çš„é¦–å…ƒç»“ç‚¹
    if fast != nil {
        slow = slow.Next
    }
    palindrome := true
    // ä»ä¸­é—´å‘ä¸¤è¾¹éå†ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯å›æ–‡é“¾è¡¨
    for head != nil {
        if head.Val != slow.Val {
            palindrome = false
        }
        // å†å°†å‰åŠéƒ¨åˆ†åè½¬å›æ¥
        next := head.Next
        head.Next = prev
        prev = head
        head = next // åŒæ—¶å°† head å¾€åç§»åŠ¨ï¼ˆå‰åŠéƒ¨åˆ†ï¼‰
        slow = slow.Next // slow å¾€åç§»åŠ¨ï¼ˆååŠéƒ¨åˆ†ï¼‰
    }
    // è·³å‡ºå¾ªç¯ï¼Œè¯´æ˜æ˜¯å›æ–‡é“¾è¡¨ï¼Œè¿”å› true
    return palindrome
}
```

</details>

<details markdown="1">
<summary>141. ç¯å½¢é“¾è¡¨ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚

`å¿«æ…¢æŒ‡é’ˆ`

```golang
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

`é›†åˆ`

```golang
func hasCycle(head *ListNode) bool {
    set := make(map[*ListNode]struct{})
    for head != nil {
        if _, ok := set[head]; ok {
            return true
        }
        set[head] = struct{}{}
        head = head.Next
    }
    return false
}
```

</details>

<details markdown="1">
<summary>142. ç¯å½¢é“¾è¡¨ IIï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹  head ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚
    
`å¿«æ…¢æŒ‡é’ˆ`

```golang
func detectCycle(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil {
        slow = slow.Next
        if fast.Next == nil {
            return nil
        }
        fast = fast.Next.Next
        // å¿«æ…¢æŒ‡é’ˆç›¸é‡
        if slow == fast {
            // ä» head å’Œç›¸é‡ç‚¹åŒæ—¶å‡ºå‘
            p := head
            // å†æ¬¡ç›¸é‡å³ä¸ºç¯çš„å…¥å£
            for p != slow {
                p = p.Next
                slow = slow.Next
            }
            return p
        }
    }
    return nil
}
```

`å“ˆå¸Œè¡¨`
```golang
func detectCycle(head *ListNode) *ListNode {
    seen := map[*ListNode]bool{}
    for head != nil {
        if seen[head] {
            return head
        }
        seen[head] = true
        head = head.Next
    }
    return nil
}
```

</details>

<details markdown="1">
<summary>21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆEasyï¼‰</summary>

> å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ å‡åº é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚

```golang
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := new(ListNode)
    cur := dummy
    for l1 != nil && l2 != nil {
        if l1.Val <= l2.Val {
            cur.Next = l1
            cur = cur.Next
            l1 = l1.Next
        } else {
            cur.Next = l2
            cur = cur.Next
            l2 = l2.Next
        }
    }
    // æœ‰ä¸€ä¸ªé“¾è¡¨ä¸ºç©ºæ—¶ï¼Œå°†å¦ä¸€ä¸ªé“¾è¡¨å‰©ä½™çš„å€¼æ”¾å…¥æ–°é“¾è¡¨ä¸­
    switch {
    case l1 != nil:
        cur.Next = l1
    case l2 != nil:
        cur.Next = l2
    }
    return dummy.Next
}
```
</details>

<details markdown="1">
<summary>2. ä¸¤æ•°ç›¸åŠ ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸¤ä¸ª éç©º çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚

> è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

```golang
func addTwoNumbers(l1, l2 *ListNode) *ListNode {
    dummy := new(ListNode)
    cur := dummy
    var carry int
    for l1 != nil || l2 != nil {
        // åˆ›å»ºæ–°èŠ‚ç‚¹ç”¨äºå­˜æ”¾ç›¸åŠ åçš„å€¼ï¼Œå› ä¸ºè¿”å›ä¸€ä¸ªæ–°é“¾è¡¨ï¼Œæ‰€ä»¥æ¯æ¬¡éƒ½è¦åˆ›å»ºä¸€ä¸ªæ–°èŠ‚ç‚¹
        cur.Next = new(ListNode)
        cur = cur.Next
        if l1 != nil {
            carry += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            carry += l2.Val
            l2 = l2.Next
        }
        // å°†ç›¸åŠ åçš„å€¼å­˜å…¥æ–°èŠ‚ç‚¹
        cur.Val = carry % 10
        // è®¡ç®—è¿›ä½å€¼
        carry /= 10
    }
    // å¦‚æœæœ€åè¿˜æœ‰è¿›ä½å€¼ï¼Œå°±å†åˆ›å»ºä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œæ­¤æ—¶ carry ä¸éœ€è¦å†é™¤ä»¥ 10
    if carry > 0 {
        cur.Next = &ListNode{Val: carry}
    }
    return dummy.Next
}
```
</details>

<details markdown="1">
<summary>19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚

```golang
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    for range n {
        head = head.Next
    }
    prev := dummy
    // å½“ head æŒ‡é’ˆæŒ‡å‘ nilï¼Œæ­¤æ—¶ prev æŒ‡é’ˆæŒ‡å‘å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    for head != nil {
        head = head.Next
        prev = prev.Next
    }
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    prev.Next = prev.Next.Next
    return dummy.Next
}
```
</details>

<details markdown="1">
<summary>24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„ç»“ç‚¹ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚

`é€’å½’`

```golang
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    // æœ€åè¿”å›çš„æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    newHead := head.Next
    // é€’å½’è°ƒç”¨ï¼Œä¼ å…¥çš„å‚æ•°æ˜¯ä¸‹ä¸€æ¬¡é€’å½’çš„å¤´èŠ‚ç‚¹ï¼Œhead æŒ‡å‘ä¸‹ä¸€æ¬¡é€’å½’çš„å¤´èŠ‚ç‚¹
    head.Next = swapPairs(newHead.Next)
    // newHead æŒ‡å‘ head
    newHead.Next = head
    return newHead
}
```

`è¿­ä»£`

```golang
func swapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    temp := dummy
    // è¿­ä»£æ¡ä»¶ï¼štemp.Next å’Œ temp.Next.Next éƒ½ä¸ä¸ºç©º
    for temp.Next != nil && temp.Next.Next != nil {
        first := temp.Next
        second := temp.Next.Next
        // äº¤æ¢ first å’Œ second
        temp.Next = second
        first.Next = second.Next
        second.Next = first
        // first æˆä¸ºä¸‹ä¸€è½®å¾…äº¤æ¢çš„å‰ç½®èŠ‚ç‚¹
        temp = first
    }
    return dummy.Next
}
```
</details>

<details markdown="1">
<summary>138. éšæœºé“¾è¡¨çš„å¤åˆ¶ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º n çš„é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªé¢å¤–å¢åŠ çš„éšæœºæŒ‡é’ˆ random ï¼Œè¯¥æŒ‡é’ˆå¯ä»¥æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»ä½•èŠ‚ç‚¹æˆ–ç©ºèŠ‚ç‚¹ã€‚æ„é€ è¿™ä¸ªé“¾è¡¨çš„ æ·±æ‹·è´ã€‚ æ·±æ‹·è´åº”è¯¥æ­£å¥½ç”± n ä¸ª å…¨æ–° èŠ‚ç‚¹ç»„æˆï¼Œå…¶ä¸­æ¯ä¸ªæ–°èŠ‚ç‚¹çš„å€¼éƒ½è®¾ä¸ºå…¶å¯¹åº”çš„åŸèŠ‚ç‚¹çš„å€¼ã€‚æ–°èŠ‚ç‚¹çš„ next æŒ‡é’ˆå’Œ random æŒ‡é’ˆä¹Ÿéƒ½åº”æŒ‡å‘å¤åˆ¶é“¾è¡¨ä¸­çš„æ–°èŠ‚ç‚¹ï¼Œå¹¶ä½¿åŸé“¾è¡¨å’Œå¤åˆ¶é“¾è¡¨ä¸­çš„è¿™äº›æŒ‡é’ˆèƒ½å¤Ÿè¡¨ç¤ºç›¸åŒçš„é“¾è¡¨çŠ¶æ€ã€‚å¤åˆ¶é“¾è¡¨ä¸­çš„æŒ‡é’ˆéƒ½ä¸åº”æŒ‡å‘åŸé“¾è¡¨ä¸­çš„èŠ‚ç‚¹ ã€‚

```golang
func copyRandomList(head *Node) *Node {
    if head == nil {
        return head
    }
    m := make(map[*Node]*Node)
    curr := head
    // éå†åŸé“¾è¡¨ï¼Œå°†åŸé“¾è¡¨çš„èŠ‚ç‚¹å’Œæ–°é“¾è¡¨çš„èŠ‚ç‚¹å­˜å‚¨åˆ° map ä¸­ï¼Œæ­¤æ—¶æ–°é“¾è¡¨çš„ next å’Œ random æŒ‡é’ˆéƒ½ä¸ºç©º
    for curr != nil {
        node := &Node{Val: curr.Val}
        m[curr] = node
        curr = curr.Next
    }
    curr = head
    // å†æ¬¡éå†åŸé“¾è¡¨ï¼Œå°†æ–°é“¾è¡¨çš„ next å’Œ random æŒ‡é’ˆæŒ‡å‘æ­£ç¡®çš„èŠ‚ç‚¹
    for curr != nil {
        node := m[curr]
        node.Next = m[curr.Next]
        node.Random = m[curr.Random]
        curr = curr.Next
    }
    // æœ€åç›´æ¥è¿”å› map ä¸­çš„å¤´èŠ‚ç‚¹ï¼Œå¯¹åº”çš„å€¼å°±æ˜¯æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    return m[head]
}
```

> åˆ©ç”¨ map å­˜å‚¨åŸé“¾è¡¨çš„èŠ‚ç‚¹å’Œæ–°é“¾è¡¨çš„èŠ‚ç‚¹ï¼Œç„¶åå†éå†ä¸€æ¬¡ï¼Œå°†æ–°é“¾è¡¨çš„ next å’Œ random æŒ‡é’ˆæŒ‡å‘æ­£ç¡®çš„èŠ‚ç‚¹

</details>

<details markdown="1">
<summary>148. æ’åºé“¾è¡¨ï¼ˆMediumï¼‰</summary>

> ç»™ä½ é“¾è¡¨çš„å¤´ç»“ç‚¹ head ï¼Œè¯·å°†å…¶æŒ‰ å‡åº æ’åˆ—å¹¶è¿”å› æ’åºåçš„é“¾è¡¨ ã€‚

```golang
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    middle := findMiddle(head)
    r := sortList(middle.Next)
    middle.Next = nil
    l := sortList(head)
    return mergeTwoLists(l, r)

}
func findMiddle(head *ListNode) *ListNode {
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow, fast = slow.Next, fast.Next.Next
    }
    return slow
}
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := new(ListNode)
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val <= l2.Val {
            curr.Next = l1
            curr = curr.Next
            l1 = l1.Next
        } else {
            curr.Next = l2
            curr = curr.Next
            l2 = l2.Next
        }
    }
    switch {
    case l1 != nil:
        curr.Next = l1
    case l2 != nil:
        curr.Next = l2
    }
    return dummy.Next
}
```

> å½’å¹¶æ’åºï¼Œæ‰¾åˆ°é“¾è¡¨ä¸­ç‚¹ï¼Œåˆ†æˆä¸¤ä¸ªé“¾è¡¨ï¼Œé€’å½’æ’åºï¼Œå†åˆå¹¶

</details>

<details markdown="1">
<summary>146. LRUç¼“å­˜ï¼ˆMediumï¼‰</summary>

> è®¾è®¡å¹¶å®ç°æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆLRUï¼‰ç¼“å­˜æœºåˆ¶ã€‚å®ç° LRUCache ç±»ï¼š

> LRUCache(int capacity) ä»¥æ­£æ•´æ•°ä½œä¸ºå®¹é‡ capacity åˆå§‹åŒ– LRU ç¼“å­˜

> int get(int key) å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1

> void put(int key, int value) å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œ

> åˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—-å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œåˆ™åº”è¯¥é€å‡ºæœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚

> å‡½æ•° get(key) å’Œ put(key, value) çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º O(1)

```golang
// é”®å€¼å¯¹ï¼Œå®ç° Value æ¥å£ï¼Œæ–¹ä¾¿é“¾è¡¨æ“ä½œ
type pair struct {
    key, value int
}
// LRU ç¼“å­˜ï¼Œä½¿ç”¨åŒå‘é“¾è¡¨å’Œå“ˆå¸Œè¡¨å®ç°
type LRUCache struct {
    capacity int                   // ç¼“å­˜å®¹é‡
    list     *list.List            // åŒå‘é“¾è¡¨
    cache    map[int]*list.Element // å“ˆå¸Œè¡¨
}
func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity,
        list.New(),
        make(map[int]*list.Element),
    }
}
func (c *LRUCache) Get(key int) int {
    // å¦‚æœ key å­˜åœ¨ï¼Œå°†èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œå¹¶è¿”å›èŠ‚ç‚¹çš„å€¼
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)
        // éœ€è¦æ–­è¨€ï¼Œå› ä¸º elem.Value æ˜¯ interface{} ç±»å‹
        return elem.Value.(pair).value
    }
    return -1
}
func (c *LRUCache) Put(key int, value int) {
    // å¦‚æœ key å­˜åœ¨ï¼Œæ›´æ–°èŠ‚ç‚¹çš„å€¼ï¼Œå¹¶å°†èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)
        // æ›´æ–°å¯¹åº” key çš„ value
        elem.Value = pair{key, value}
        return
    }
    // æ·»åŠ æ–°èŠ‚ç‚¹ä¹‹å‰ï¼Œéœ€è¦åˆ¤æ–­ç¼“å­˜æ˜¯å¦å·²æ»¡
    // å¦‚æœ cache å·²æ»¡ï¼Œç§»é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹ï¼Œå¹¶åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹ä»¥åŠåŒå‘é“¾è¡¨ä¸­çš„èŠ‚ç‚¹
    // åˆ é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹å°±ç¬¦åˆäº† LRU çš„è¦æ±‚ï¼Œå› ä¸ºå°¾éƒ¨èŠ‚ç‚¹æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ï¼Œæ¯æ¬¡æ’å…¥æ–°èŠ‚ç‚¹æˆ–è€…æ›´æ–°èŠ‚ç‚¹éƒ½æ˜¯åœ¨é“¾è¡¨å¤´éƒ¨
    if c.list.Len() == c.capacity {
        last := c.list.Back()
        delete(c.cache, last.Value.(pair).key)
        c.list.Remove(last)
    }
    // åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹ï¼Œå¹¶åœ¨å“ˆå¸Œè¡¨ä¸­æ·»åŠ  key å’ŒèŠ‚ç‚¹çš„æ˜ å°„
    // PushFront è¿”å›çš„æ˜¯ *list.Elementï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥èµ‹å€¼ç»™ mapï¼ŒåŒæ—¶å®Œæˆäº†ä¸¤ä¸ªæ“ä½œ
    c.cache[key] = c.list.PushFront(pair{key, value})
}

```
</details>

### äºŒå‰æ ‘

<details markdown="1">
<summary>94. äºŒå‰æ ‘çš„ä¸­åºéå†ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› å®ƒçš„ ä¸­åº éå† ã€‚

`é€’å½’`

```golang
func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    var res []int
    res = append(res, inorderTraversal(root.Left)...)
    res = append(res, root.Val)
    res = append(res, inorderTraversal(root.Right)...)
    return res
}
```

`è¿­ä»£`

```golang
func inorderTraversal(root *TreeNode) []int {
    var res []int
    var stack []*TreeNode
    for curr := root; curr != nil || len(stack) > 0; {
        // æ²¿ç€å·¦å­æ ‘ä¸€ç›´å¾€ä¸‹èµ°ï¼Œç›´åˆ°èµ°åˆ°å¶å­èŠ‚ç‚¹
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }
        // æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œå¹¶è®¿é—®è¯¥èŠ‚ç‚¹
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        res = append(res, curr.Val)
        // è®¿é—®å³å­æ ‘
        curr = curr.Right
    }
    return res
}
```
</details>

<details markdown="1">
<summary>104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ root ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚äºŒå‰æ ‘çš„ æœ€å¤§æ·±åº¦ æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

```golang
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1
}
```
</details>

<details markdown="1">
<summary>226. ç¿»è½¬äºŒå‰æ ‘ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€é¢—äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œç¿»è½¬è¿™é¢—äºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

```golang
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    // é€’å½’ç¿»è½¬å·¦å³å­æ ‘
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```
</details>

<details markdown="1">
<summary>101. å¯¹ç§°äºŒå‰æ ‘ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

```golang
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return symmetric(root.Left, root.Right)
}
func symmetric(p, q *TreeNode) bool {
    switch {
    case p == nil || q == nil:
        return p == q
    case p.Val != q.Val:
        return false
    }
    return symmetric(p.Left, q.Right) && symmetric(p.Right, q.Left)
}
```
</details>

<details markdown="1">
<summary>543. äºŒå‰æ ‘çš„ç›´å¾„ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¯¥æ ‘çš„ ç›´å¾„ ã€‚äºŒå‰æ ‘çš„ ç›´å¾„ æ˜¯æŒ‡æ ‘ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ€é•¿è·¯å¾„çš„ é•¿åº¦ ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç»è¿‡ä¹Ÿå¯èƒ½ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ root ã€‚ä¸¤èŠ‚ç‚¹ä¹‹é—´è·¯å¾„çš„ é•¿åº¦ ç”±å®ƒä»¬ä¹‹é—´è¾¹æ•°è¡¨ç¤ºã€‚

```golang
func diameterOfBinaryTree(root *TreeNode) int {
    var res int
    var diameter func(*TreeNode) int
    diameter = func(root *TreeNode) int {
        if root == nil {
            return 0
        }
        // é€’å½’è®¡ç®—å·¦å³å­æ ‘çš„æ·±åº¦
        left := diameter(root.Left)
        right := diameter(root.Right)
        // è®¡ç®—å½“å‰èŠ‚ç‚¹çš„æœ€å¤§ç›´å¾„
        if left+right > res {
            res = left + right
        }
        // è¿”å›å½“å‰èŠ‚ç‚¹çš„æ·±åº¦
        depth := left
        if right > depth {
            depth = right
        }
        return depth + 1
    }
    diameter(root)
    return res
}
```
</details>

<details markdown="1">
<summary>102. äºŒå‰æ ‘çš„å±‚åºéå†ï¼ˆMediumï¼‰</summary>

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

```golang
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    var res [][]int
    // æ¨¡æ‹Ÿé˜Ÿåˆ—
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        var level []int
        // éå†å½“å‰å±‚çš„èŠ‚ç‚¹
        for range queue  {
            node := queue[0]
            queue = queue[1:]
            // å°†å‡ºé˜Ÿå…ƒç´ çš„å€¼å­˜å…¥ levelï¼Œè®°å½•å½“å‰å±‚çš„å€¼
            level = append(level, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        // å°†å½“å‰å±‚çš„å€¼å­˜å…¥ res
        res = append(res, level)
    }
    return res
}
```
</details>

<details markdown="1">
<summary>108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚

```golang
func sortedArrayToBTS(nums []int) *TreeNode {
    if len(nums) == 0 {
        return nil
    }
    mid := len(nums) / 2
    return &TreeNode{
        Val:   nums[mid],
        // é€’å½’è°ƒç”¨ï¼Œå°†æ•°ç»„å·¦è¾¹çš„å…ƒç´ æ„é€ å·¦å­æ ‘ï¼Œå³è¾¹çš„å…ƒç´ æ„é€ å³å­æ ‘
        Left:  sortedArrayToBTS(nums[:mid]),
        Right: sortedArrayToBTS(nums[mid+1:]),
    }
}
```
> ä¸­åºéå†ï¼Œæ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹

</details>

<details markdown="1">
<summary>98. éªŒè¯äºŒå‰æœç´¢æ ‘ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

`é€’å½’`

```golang
func isValidBST(root *TreeNode) bool {
    var dfs func(*TreeNode, int, int) bool
    dfs = func(root *TreeNode, min, max int) bool {
        if root == nil {
            return true
        }
        // å¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼ä¸åœ¨ [min, max] çš„èŒƒå›´å†…ï¼Œåˆ™è¿”å› false
        if root.Val <= min || root.Val >= max {
            return false
        }
        return dfs(root.Left, min, root.Val) && dfs(root.Right, root.Val, max)
    }
    return dfs(root, -1<<63, 1<<63-1)
}
```

`éé€’å½’ä¸­åºéå†`

```golang
func isValidBST(root *TreeNode) bool {
    var stack []*TreeNode
    var pre *TreeNode
    for len(stack) > 0 || root != nil {
        // å°†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å·¦å­èŠ‚ç‚¹å…¥æ ˆ
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        // å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // å¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼å°äºç­‰äº pre èŠ‚ç‚¹çš„å€¼ï¼Œåˆ™ä¸æ˜¯äºŒå‰æœç´¢æ ‘
        if pre != nil && root.Val <= pre.Val {
            return false
        }
        // æ›´æ–° pre èŠ‚ç‚¹
        pre = root
        // å¤„ç†å³å­èŠ‚ç‚¹
        root = root.Right
    }
    return true
}
```
</details>

<details markdown="1">
<summary>230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œå’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬kä¸ªæœ€å°å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰

```golang
func kthSmallest(root *TreeNode, k int) int {
    res := []int{}
    var inorder func(*TreeNode)
    inorder = func(tn *TreeNode) {
        if tn == nil {
            return
        }
        inorder(tn.Left)
        res = append(res, tn.Val)
        inorder(tn.Right)
    }
    inorder(root)
    return res[k-1]
}
```

> ä¸­åºéå†ï¼Œå°†èŠ‚ç‚¹å€¼å­˜å…¥åˆ‡ç‰‡ï¼Œè¿”å›ç¬¬ k ä¸ªå…ƒç´ 

</details>

<details markdown="1">
<summary>199. äºŒå‰æ ‘çš„å³è§†å›¾ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼

```golang
func rightSideView(root *TreeNode) []int {
    var res []int
    var dfs func(*TreeNode, int)
    dfs = func(tn *TreeNode, depth int) {
        if tn == nil {
            return
        }
        if depth == len(res) {
            res = append(res, tn.Val)
        }
        dfs(tn.Right, depth+1)
        dfs(tn.Left, depth+1)
    }
    dfs(root, 0)
    return res
}
```

> æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ¯å±‚åªå–æœ€å³è¾¹çš„èŠ‚ç‚¹

</details>

<details markdown="1">
<summary>114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ï¼ˆMediumï¼‰</summary>

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ root ï¼Œè¯·ä½ å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ï¼šå±•å¼€åçš„å•é“¾è¡¨åº”è¯¥åŒæ ·ä½¿ç”¨ TreeNodeï¼Œå…¶ä¸­ right å­æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè€Œå·¦å­æŒ‡é’ˆå§‹ç»ˆä¸º null ã€‚å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥ä¸äºŒå‰æ ‘ å…ˆåºéå† é¡ºåºç›¸åŒã€‚

```golang
func flatten(root *TreeNode) {
    curr := root
    // é€šè¿‡å³æŒ‡é’ˆéå†
    for curr != nil {
        // æå‰è®°å½•å½“å‰èŠ‚ç‚¹çš„å³å­æ ‘
        right := curr.Right
        // å°†å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘æ’å…¥åˆ°å³å­æ ‘çš„åœ°æ–¹
        curr.Left, curr.Right = nil, curr.Left
        // å°†åŸæ¥çš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ€å³è¾¹èŠ‚ç‚¹
        prev := curr
        for prev.Right != nil {
            prev = prev.Right
        }
        // å°†åŸæ¥çš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ€å³è¾¹èŠ‚ç‚¹
        prev.Right = right
        curr = curr.Right
    }
}
```
</details>

<details markdown="1">
<summary>105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ preorder å’Œ inorder ï¼Œå…¶ä¸­ preorder æ˜¯äºŒå‰æ ‘çš„å…ˆåºéå†ï¼Œ inorder æ˜¯åŒä¸€æ£µæ ‘çš„ä¸­åºéå†ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

```golang
func buildTree(preorder, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    // ä»ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œæ ¹èŠ‚ç‚¹å³ä¸ºå‰åºéå†çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    i := func(order []int, v int) int {
        var index int
        for order[index] != v {
            index++
        }
        return index
    }(inorder, preorder[0])
    // æ ¹èŠ‚ç‚¹ä¸º preorder[0], ä¸­åºéå†çš„æ ¹èŠ‚ç‚¹ç´¢å¼•ä¸º i
    // å‰åºéå†çš„å·¦å­æ ‘ä¸º preorder[1:i+1], ä¸­åºéå†çš„å·¦å­æ ‘ä¸º inorder[:i]
    // å‰åºéå†çš„å³å­æ ‘ä¸º preorder[i+1:], ä¸­åºéå†çš„å³å­æ ‘ä¸º inorder[i+1:]
    return &TreeNode{
        Val:   preorder[0],
        Left:  buildTree(preorder[1:i+1], inorder[:i]),
        Right: buildTree(preorder[i+1:], inorder[i+1:]),
    }
}
```
</details>

<details markdown="1">
<summary>437. è·¯å¾„æ€»å’Œ IIIï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œå’Œä¸€ä¸ªæ•´æ•° targetSum ï¼Œæ±‚è¯¥äºŒå‰æ ‘é‡ŒèŠ‚ç‚¹å€¼ä¹‹å’Œç­‰äº targetSum çš„è·¯å¾„çš„æ•°ç›®ã€‚ è·¯å¾„ ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚

```golang
func pathSum(root *TreeNode, targetSum int) int {
    preSumMap := map[int]int{0: 1}
    var f func(*TreeNode, int) int
    f = func(root *TreeNode, curSum int) int {
        var ans int
        if root == nil {
            return 0
        }
        curSum += root.Val
        // è¿™æ¡è·¯å¾„å³ä¸º curSum - (curSum - targetSum) = targetSum
        if cnt, ok := preSumMap[curSum-targetSum]; ok {
            ans += cnt
        }
        // æ›´æ–°å‰ç¼€å’Œ curSum çš„æ¬¡æ•°
        preSumMap[curSum]++
        // é€’å½’å·¦å³å­æ ‘
        ans += f(root.Left, curSum)
        ans += f(root.Right, curSum)
        // å›æº¯ï¼Œæ¢å¤çŠ¶æ€
        preSumMap[curSum]--
        return ans
    }
    return f(root, 0)
}
```

> é€’å½’ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å‰ç¼€å’Œï¼Œé€’å½’éå†äºŒå‰æ ‘ï¼Œè®¡ç®—è·¯å¾„å’Œç­‰äºç›®æ ‡å€¼çš„è·¯å¾„æ•°

</details>

<details markdown="1">
<summary>236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

```golang
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

> é€’å½’ï¼Œå¦‚æœå·¦å­æ ‘å’Œå³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜ p å’Œ q åˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸­ï¼Œè¿”å› rootï¼Œå¦åˆ™è¿”å›ä¸ä¸ºç©ºçš„å­æ ‘

</details>

### å›¾è®º

<details markdown="1">
<summary>200. å²›å±¿æ•°é‡ï¼ˆMediumï¼‰</summary>

>ç»™ä½ ä¸€ä¸ªç”±Â '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚

> å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚

```golang
func numIslands(grid [][]byte) int {
    visited := make([][]bool, len(grid))
    for i := range visited {
        visited[i] = make([]bool, len(grid[i]))
    }
    var num int
    for i, r := range grid {
        for j, c := range r {
            if c == '0' || visited[i][j] {
                continue
            }
            num++
            visit(grid, visited, i, j)
        }
    }
    return num
}
func visit(grid [][]byte, visited [][]bool, i, j int) {
    if grid[i][j] == '0' || visited[i][j] {
        return
    }
    visited[i][j] = true
    if i > 0 {
        visit(grid, visited, i-1, j)
    }
    if i < len(grid)-1 {
        visit(grid, visited, i+1, j)
    }
    if j > 0 {
        visit(grid, visited, i, j-1)
    }
    if j < len(grid[i])-1 {
        visit(grid, visited, i, j+1)
    }
}
```
> æ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†äºŒç»´ç½‘æ ¼ï¼Œé‡åˆ°å²›å±¿æ—¶ï¼Œé€’å½’éå†ç›¸é‚»çš„å²›å±¿ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®

</details>

<details markdown="1">
<summary>207. è¯¾ç¨‹è¡¨ï¼ˆMediumï¼‰</summary>

> ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® numCourses é—¨è¯¾ç¨‹ï¼Œè®°ä¸ºÂ 0Â åˆ°Â numCourses - 1 ã€‚åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„Â prerequisites ç»™å‡ºï¼Œå…¶ä¸­Â prerequisites[i] = [ai, bi] ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹Â ai åˆ™ å¿…é¡» å…ˆå­¦ä¹ è¯¾ç¨‹Â  bi ã€‚

> åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false 

```golang
func canFinish(numCourses int, prerequisites [][]int) bool {
    edges := make([][]int, numCourses)
    inDegree := make([]int, numCourses)
    for _, info := range prerequisites {
        edges[info[1]] = append(edges[info[1]], info[0])
        inDegree[info[0]]++
    }
    queue := []int{}
    for i := 0; i < numCourses; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        numCourses--
        for _, next := range edges[node] {
            inDegree[next]--
            if inDegree[next] == 0 {
                queue = append(queue, next)
            }
        }
    }
    return numCourses == 0
}
```

> åŸºäº BFS çš„æ‹“æ‰‘æ’åºï¼Œç»Ÿè®¡æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ï¼Œå°†å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œéå†é˜Ÿåˆ—ï¼Œå°†å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹å‡ºé˜Ÿï¼Œæ›´æ–°å…¶é‚»æ¥èŠ‚ç‚¹çš„å…¥åº¦ï¼Œå¦‚æœå…¥åº¦ä¸º 0ï¼ŒåŠ å…¥é˜Ÿåˆ—ï¼Œæœ€ååˆ¤æ–­æ˜¯å¦æ‰€æœ‰èŠ‚ç‚¹éƒ½å…¥é˜Ÿ

</details>

<details markdown="1">
<summary>208. å®ç° Trie (å‰ç¼€æ ‘)ï¼ˆMediumï¼‰</summary>

> å®ç° Trie ç±»ï¼ŒåŒ…å« insertã€searchã€startsWith æ–¹æ³•

```golang
type Trie struct {
    child [26]*Trie // å­èŠ‚ç‚¹
    isEnd bool      // æ˜¯å¦æ˜¯å•è¯ç»“å°¾
}
func Constructor() Trie {
    return Trie{}
}
func (t *Trie) Insert(word string) {
    node := t
    for _, ch := range word {
        ch -= 'a'
        if node.child[ch] == nil {
            node.child[ch] = &Trie{}
        }
        node = node.child[ch]
    }
    // éå†å®Œï¼Œå°†å½“å‰èŠ‚ç‚¹æ ‡è®°ä¸ºå­—ç¬¦ä¸²çš„ç»“å°¾
    node.isEnd = true
}
func (t *Trie) SearchPrefix(prefix string) *Trie {
    node := t
    for _, ch := range prefix {
        ch -= 'a'
        if node.child[ch] == nil {
            return nil
        }
        node = node.child[ch]
    }
    // è¿”å›æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³å‰ç¼€çš„æœ€åä¸€ä¸ªå­—ç¬¦
    return node
}
func (t *Trie) Search(word string) bool {
    node := t.SearchPrefix(word)
    // node != nil è¯´æ˜ word çš„æ‰€æœ‰å‰ç¼€éƒ½å­˜åœ¨, ä¸”æœ€åä¸€ä¸ªå‰ç¼€çš„ isEnd ä¸º true
    return node != nil && node.isEnd
}
func (t *Trie) StartsWith(prefix string) bool {
    return t.SearchPrefix(prefix) != nil
}
```
</details>

### å›æº¯

<details markdown="1">
<summary>46. å…¨æ’åˆ—ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

```golang
func permute(nums []int) [][]int {
    var res [][]int
    var f func([]int, []int)
    f = func(nums, path []int) {
        if len(nums) == 0 {
            res = append(res, path)
            return
        }
        for i, v := range nums {
            // å°† nums[:i] å’Œ nums[i+1:] æ‹¼æ¥èµ·æ¥ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ï¼Œå†å°† v æ·»åŠ åˆ°æœ«å°¾
            // è¿™æ ·å°±å¾—åˆ°äº†ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ï¼Œå…¶ä¸­ä¸åŒ…å«åŸå§‹åˆ‡ç‰‡ nums ä¸­çš„ç¬¬ i ä¸ªæ•°
            newNums := append(append([]int{}, nums[:i]...), nums[i+1:]...)
            newPath := append(path, v)
            f(newNums, newPath)
        }
    }
    f(nums, []int{})
    return res
}
```

> å›æº¯ï¼Œé€’å½’éå†æ•°ç»„ï¼Œå°†æ¯ä¸ªå…ƒç´ åŠ å…¥è·¯å¾„ï¼Œå†é€’å½’éå†å‰©ä½™å…ƒç´ 

</details>

<details markdown="1">
<summary>78. å­é›†ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  äº’ä¸ç›¸åŒ ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è§£é›†ã€‚

```golang
func subsets(nums []int) [][]int {
    sets := make([][]int, 1, 1<<uint(len(nums)))
    for _, num := range nums {
        for _, set := range sets {
            s := make([]int, len(set), len(set)+1)
            copy(s, set)
            // é¦–å…ˆå°† num æ·»åŠ åˆ° s ä¸­ï¼Œç„¶åå°† s æ·»åŠ åˆ° sets ä¸­
            sets = append(sets, append(s, num))
        }
    }
    return sets
}
```
</details>

<details markdown="1">
<summary>17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— 2-9 çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚
> ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚

> 1:!@#   2:abc   3:def

> 4:ghi   5:jkl   6:mno

> 7:pqrs  8:tuv   9:wxyz

> *: +    0: _    #: %

```golang
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return nil
    }
    buttons := []string{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
    var results []string
    temp := make([]byte, len(digits))
    var dfs func(int)
    dfs = func(i int) {
        // å¦‚æœå·²ç»éå†å®Œæœ€åä¸€ä½ï¼Œæ­¤æ—¶ i+1=digitsï¼ŒæŠŠç»“æœåŠ å…¥åˆ°ç»“æœé›†ä¸­
        if i == len(digits) {
            results = append(results, string(temp))
            return
        }
        // è·å–å½“å‰æ•°å­—å¯¹åº”å­—æ¯çš„ byte æ•°ç»„ï¼Œå› ä¸ºæ•°å­— 9 é”®çš„å­—æ¯æ˜¯ä» 2 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦å‡å» 2
        letters := buttons[digits[i]-'2']
        for j := 0; j < len(letters); j++ {
            temp[i] = letters[j]
            dfs(i + 1)
        }
    }
    // ä»å‚æ•° digits çš„ç¬¬ä¸€ä½å¼€å§‹éå†
    dfs(0)
    return results
}
```

> å›æº¯ï¼Œé€’å½’éå†æ•°å­—å¯¹åº”çš„å­—æ¯ï¼Œå°†æ¯ä¸ªå­—æ¯åŠ å…¥è·¯å¾„ï¼Œå†é€’å½’éå†ä¸‹ä¸€ä¸ªæ•°å­—

</details>

<details markdown="1">
<summary>39. ç»„åˆæ€»å’Œï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ— é‡å¤å…ƒç´ çš„æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚candidates ä¸­çš„æ•°å­—å¯ä»¥æ— é™åˆ¶é‡å¤è¢«é€‰å–ã€‚

```golang
func combinationSum(candidates []int, target int) [][]int {
    var res [][]int
    var dfs func([]int, int, int)
    dfs = func(comb []int, index, target int) {
        // å¦‚æœ target ä¸º 0ï¼Œè¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªç»„åˆï¼Œå°†å®ƒæ”¾å…¥ç»“æœä¸­ï¼Œç„¶åè¿”å›
        if target == 0 {
            res = append(res, append([]int{}, comb...))
            return
        }
        // ä» index å¼€å§‹éå† candidates
        for i, c := range candidates[index:] {
            if c <= target {
                // æ³¨æ„è¿™é‡Œçš„ index+iï¼Œå› ä¸º candidates ä¸­çš„æ•°å­—å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥ä¸‹ä¸€è½®æœç´¢çš„èµ·ç‚¹ä»ç„¶æ˜¯ index+i
                // target - c ä¸ºä¸‹ä¸€è½®æœç´¢çš„ç›®æ ‡
                dfs(append(comb, c), index+i, target-c)
            }
        }
    }
    dfs(nil, 0, target)
    return res
}
```
</details>

<details markdown="1">
<summary>22. æ‹¬å·ç”Ÿæˆï¼ˆMediumï¼‰</summary>

> æ•°å­— n ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” æœ‰æ•ˆçš„ æ‹¬å·ç»„åˆã€‚

```golang
func generateParenthesis(n int) []string {
    pair := make([]byte, n*2)
    var dfs func([]string, []byte, int, int, int) []string
    dfs = func(pairs []string, pair []byte, n, left, right int) []string {
        // å¦‚æœå·¦å’Œå³æ‹¬å·éƒ½ç”¨å®Œäº†ï¼Œå°±åŠ å…¥åˆ°ç»“æœä¸­
        if left == n && right == n {
            return append(pairs, string(pair))
        }
        // å¦‚æœå·¦æ‹¬å·è¿˜æœ‰å‰©ä½™ï¼Œå°±å¯ä»¥æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        if left < n {
            pair[left+right] = '('
            pairs = dfs(pairs, pair, n, left+1, right)
        }
        // å¦‚æœå³æ‹¬å·çš„æ•°é‡å°äºå·¦æ‹¬å·çš„æ•°é‡ï¼Œå°±å¯ä»¥æ”¾ä¸€ä¸ªå³æ‹¬å·
        if right < left {
            pair[left+right] = ')'
            pairs = dfs(pairs, pair, n, left, right+1)
        }
        return pairs
    }
    return dfs(nil, pair, n, 0, 0)
}
```
</details>

<details markdown="1">
<summary>79. å•è¯æœç´¢ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ª m x n äºŒç»´å­—ç¬¦ç½‘æ ¼ board å’Œä¸€ä¸ªå­—ç¬¦ä¸²å•è¯ word ã€‚å¦‚æœ word å­˜åœ¨äºç½‘æ ¼ä¸­ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

```golang
func exist(board [][]byte, word string) bool {
    m, n := len(board), len(board[0])
    used := make([][]bool, m)
    for i := range used {
        used[i] = make([]bool, n)
    }
    var canFind func(r, c, i int) bool
    canFind = func(r, c, i int) bool {
        if i == len(word) {
            return true
        }
        if r < 0 || r >= m || c < 0 || c >= n {
            return false
        }
        // å·²ç»è®¿é—®è¿‡æˆ–è€…ä¸ç¬¦åˆå½“å‰å­—ç¬¦
        if used[r][c] || board[r][c] != word[i] {
            return false
        }
        used[r][c] = true
        // é—´æ¥å®ç°äº†å›æº¯å’Œå‰ªæ
        if canFind(r-1, c, i+1) || canFind(r+1, c, i+1) || canFind(r, c-1, i+1) || canFind(r, c+1, i+1) {
            return true
        } else {
            used[r][c] = false // é‡æ–°æ ‡è®°ä¸ºæœªè®¿é—®, å› ä¸ºä¸‹ä¸€æ¬¡å¯èƒ½ä¼šè®¿é—®åˆ°
            return false
        }
    }
    // éå†æ‰€æœ‰çš„èµ·ç‚¹
    for i := range board {
        for j := range board[i] {
            if canFind(i, j, 0) {
                return true
            }
        }
    }
    return false
}
```
</details>

<details markdown="1">
<summary>131. åˆ†å‰²å›æ–‡ä¸²ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s, è¯·ä½ å°† s åˆ†å‰²æˆä¸€äº›å­ä¸², ä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸². è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚

```golang
func partition(s string) [][]string {
    path := []string{}
    ans := [][]string{}
    n := len(s)
    var dfs func(int, int)
    dfs = func(index, start int) {
        if index == n {
            ans = append(ans, append([]string(nil), path...))
            return
        }
        // ä¸é€‰ index å’Œ index+1 ä¹‹é—´çš„é€—å·
        if index < n-1 {
            dfs(index+1, start)
        }
        // é€‰ index å’Œ index+1 ä¹‹é—´çš„é€—å·, æŠŠ s[index] ä½œä¸ºå­ä¸²çš„æœ€åä¸€ä¸ªå­—ç¬¦
        if isPalindrome(s, start, index) {
            path = append(path, s[start:index+1])
            dfs(index+1, index+1)
            path = path[:len(path)-1]
        }
    }
    dfs(0, 0)
    return ans
}
func isPalindrome(s string, left, right int) bool {
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```
</details>

### äºŒåˆ†æŸ¥æ‰¾

<details markdown="1">
<summary>35. æœç´¢æ’å…¥ä½ç½®ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ’åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ã€‚è¯·å¿…é¡»ä½¿ç”¨æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•ã€‚

```golang
func searchInsert(nums []int, target int) int {
    i, j := 0, len(nums)
    for i < j {
        mid := int(uint(i+j) >> 1)
        switch {
        case nums[mid] < target:
            i = mid + 1
        case nums[mid] > target:
            j = mid
        default:
            return mid
        }
    }
    return i
}
```
</details>

<details markdown="1">
<summary>74. æœç´¢äºŒç»´çŸ©é˜µï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ»¡è¶³ä¸‹è¿°ä¸¤æ¡å±æ€§çš„ m x n æ•´æ•°çŸ©é˜µï¼šæ¯è¡Œä¸­çš„æ•´æ•°ä»å·¦åˆ°å³æŒ‰éé€’å‡é¡ºåºæ’åˆ—ã€‚æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°å¤§äºå‰ä¸€è¡Œçš„æœ€åä¸€ä¸ªæ•´æ•°ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•° target ï¼Œå¦‚æœ target åœ¨çŸ©é˜µä¸­ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚

```golang
func searchMatrix(matrix [][]int, target int) bool {
    for _, row := range matrix {
        i := sort.SearchInts(row, target)
        if i < len(row) && row[i] == target {
            return true
        }
    }
    return false
}
```
</details>

<details markdown="1">
<summary>34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæŒ‰ç…§éé€’å‡é¡ºåºæ’åˆ—çš„æ•´æ•°æ•°ç»„ numsï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯·ä½ æ‰¾å‡ºç»™å®šç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®ã€‚å¦‚æœæ•°ç»„ä¸­ä¸å­˜åœ¨ç›®æ ‡å€¼ targetï¼Œè¿”å› [-1, -1]ã€‚ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

```golang
func searchRange(nums []int, target int) []int {
    // ä½¿ç”¨ SearchInts åœ¨ nums ä¸­æœç´¢ targetï¼Œå¦‚æœæ‰¾åˆ°åˆ™è¿”å›å…¶ç´¢å¼•ï¼Œå¦åˆ™è¿”å›å°†ä¼šæ’å…¥çš„ç´¢å¼•
    left := sort.SearchInts(nums, target)
    if left == len(nums) || nums[left] != target {
        return []int{-1, -1}
    }
    // æŒ‰ç…§é¢˜ç›®æ„æ€ï¼Œå› ä¸ºå­˜åœ¨å·¦ç´¢å¼•äº†ï¼Œæ‰€ä»¥ä¸éœ€è¦å†å¯¹å³ç´¢å¼•è¿›è¡Œåˆ¤æ–­æ˜¯å¦è¶Šç•Œå’Œæ˜¯å¦ç­‰äº target
    // æ‰¾åˆ° target+1 çš„ç´¢å¼•ï¼Œå†å¾€å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®, å³ä¸º target çš„æœ€å³ç´¢å¼•
    right := sort.SearchInts(nums, target+1) - 1
    return []int{left, right}
}
```
</details>

<details markdown="1">
<summary>33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ï¼ˆMediumï¼‰</summary>

> æ•´æ•°æ•°ç»„ nums æŒ‰å‡åºæ’åˆ—ï¼Œæ•°ç»„ä¸­çš„å€¼ äº’ä¸ç›¸åŒ ã€‚åœ¨ä¼ é€’ç»™å‡½æ•°ä¹‹å‰ï¼Œnums åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ kï¼ˆ0 <= k < nums.lengthï¼‰ä¸Šè¿›è¡Œäº† æ—‹è½¬ ï¼Œä½¿æ•°ç»„å˜ä¸º [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]ï¼ˆ0 ä¸‹æ ‡å¼€å§‹ï¼‰ã€‚ç»™ä½  æœç´¢ç›®æ ‡å€¼ target ï¼Œå¦‚æœæ•°ç»„ä¸­å­˜åœ¨è¿™ä¸ªç›®æ ‡å€¼ï¼Œåˆ™è¿”å›å®ƒçš„ç´¢å¼•ï¼Œå¦åˆ™è¿”å› -1 ã€‚

```golang
func search(nums []int, target int) int {
    lo, hi := 0, len(nums)
    for lo < hi {
        mid := int(uint(lo+hi) >> 1)
        if nums[mid] == target {
            return mid
        }
        if nums[0] <= nums[mid] {
            if nums[0] <= target && target < nums[mid] {
                hi = mid
            } else {
                lo = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[len(nums)-1] {
                lo = mid + 1
            } else {
                hi = mid
            }
        }
    }
    return -1
}
```
> äºŒåˆ†æŸ¥æ‰¾ï¼Œæ ¹æ® nums[0] å’Œ nums[mid] çš„å…³ç³»åˆ¤æ–­ target åœ¨å·¦åŠéƒ¨åˆ†è¿˜æ˜¯å³åŠéƒ¨åˆ†ï¼Œå†æ ¹æ® target å’Œ nums[mid] çš„å…³ç³»æ›´æ–° lo å’Œ hi

</details>

<details markdown="1">
<summary>153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå…ƒç´ å€¼ äº’ä¸ç›¸åŒ çš„æ•°ç»„ nums ï¼Œå®ƒåŸæ¥æ˜¯ä¸€ä¸ªå‡åºæ’åˆ—çš„æ•°ç»„ï¼Œå¹¶æŒ‰ä¸Šè¿°æƒ…å½¢è¿›è¡Œäº†å¤šæ¬¡æ—‹è½¬ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­çš„ æœ€å°å…ƒç´  ã€‚

```golang
func findMin(nums []int) int {
    lo, hi := 0, len(nums)-1
    for lo < hi {
        mid := int(uint(lo+hi) >> 1)
        // å¦‚æœä¸­é—´å€¼å¤§äºæœ€å³è¾¹çš„å€¼ï¼Œè¯´æ˜æœ€å°å€¼åœ¨å³è¾¹
        if nums[mid] > nums[hi] {
            lo = mid + 1
        } else {
            // åŒ…å« nums[mid] == nums[hi] çš„æƒ…å†µï¼Œæ‰€ä»¥ä¸èƒ½ç”¨ hi = mid - 1
            hi = mid
        }
    }
    return nums[lo]
}
```
</details>

<details markdown="1">
<summary>162. å¯»æ‰¾å³°å€¼ï¼ˆMediumï¼‰</summary>

> å³°å€¼å…ƒç´ æ˜¯æŒ‡å…¶å€¼å¤§äºå·¦å³ç›¸é‚»å€¼çš„å…ƒç´ ã€‚è¿”å›æ•°ç»„ä¸­çš„ä»»ä½•ä¸€ä¸ªå³°å€¼å³å¯

```golang
func findPeakElement(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        h := int(uint(l+r) >> 1)
        if nums[h] > nums[h+1] {
            r = h
        } else {
            l = h + 1
        }
    }
    return l
}
```

> äºŒåˆ†æŸ¥æ‰¾ï¼Œå¦‚æœä¸­é—´å€¼å¤§äºå³è¾¹å€¼ï¼Œè¯´æ˜å³°å€¼åœ¨å·¦è¾¹ï¼Œå¦åˆ™åœ¨å³è¾¹

</details>

### æ ˆ

<details markdown="1">
<summary>20. æœ‰æ•ˆçš„æ‹¬å·ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']' çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼šå·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚æ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚

```golang
func isValid(s string) bool {
    pairs := map[byte]byte{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    stack := []byte{}
    for _, ch := range []byte(s) {
        if pair, ok := pairs[ch]; ok {
            if len(stack) == 0 || stack[len(stack)-1] != pair {
                return false
            }
            stack = stack[:len(stack)-1]
        } else {
            stack = append(stack, ch)
        }
    }
    return len(stack) == 0
}
```

> ä½¿ç”¨æ ˆï¼Œéå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°å·¦æ‹¬å·å…¥æ ˆï¼Œé‡åˆ°å³æ‹¬å·å‡ºæ ˆï¼Œåˆ¤æ–­æ˜¯å¦åŒ¹é…

</details>

<details markdown="1">
<summary>155. æœ€å°æ ˆï¼ˆMediumï¼‰</summary>

> è®¾è®¡ä¸€ä¸ªæ”¯æŒ push ï¼Œpop ï¼Œtop æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚

```golang
type MinStack struct {
    stack    []int
    minstack []int // è¾…åŠ©æ ˆï¼Œå­˜å‚¨æœ€å°å€¼
}
func Constructor() MinStack {
    return MinStack{
        stack:    []int{},
        minstack: []int{math.MaxInt64},
    }
}
// å½“ä¸€ä¸ªå…ƒç´ è¦å…¥æ ˆæ—¶ï¼Œé¦–å…ˆå–å½“å‰è¾…åŠ©æ ˆçš„æ ˆé¡¶å­˜å‚¨çš„æœ€å°å€¼ï¼Œç„¶åä¸å½“å‰å…ƒç´ æ¯”è¾ƒå‡ºæœ€å°å€¼
// å°†å¾—å‡ºçš„æœ€å°å€¼æ¨å…¥è¾…åŠ©æ ˆçš„æ ˆé¡¶ï¼Œå³è¾…åŠ©æ ˆçš„æ ˆé¡¶å­˜å‚¨å½“å‰æ ˆæ‰€å¯¹åº”çš„æœ€å°å€¼
func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    top := this.minstack[len(this.minstack)-1]
    this.minstack = append(this.minstack, min(val, top))
}
// åˆ é™¤å †æ ˆé¡¶éƒ¨çš„å…ƒç´ ï¼Œå°†è¾…åŠ©æ ˆçš„æ ˆé¡¶å…ƒç´ ä¸€åŒå¼¹å‡º
func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minstack = this.minstack[:len(this.minstack)-1]
}
func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}
func (this *MinStack) GetMin() int {
    return this.minstack[len(this.minstack)-1]
}
```
</details>

<details markdown="1">
<summary>394. å­—ç¬¦ä¸²è§£ç ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚ç¼–ç è§„åˆ™æ˜¯: k[encoded_string] ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ encoded_string æ­£å¥½é‡å¤ k æ¬¡ã€‚æ³¨æ„ k ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œæ–¹æ‹¬å·æ ¼å¼æ­£ç¡®ç­‰ã€‚
```golang
func decodeString(s string) string {
    cntStack, strStack := []int{}, []string{}
    currNum, currStr := 0, ""
    for _, v := range s {
        switch {
        case v >= '0' && v <= '9':
            currNum = currNum*10 + int(v-'0')
        case v == '[':
            cntStack = append(cntStack, currNum)
            strStack = append(strStack, currStr)
            currNum, currStr = 0, ""
        case v == ']':
            // ä»æ•°å­—æ ˆä¸­å¼¹å‡ºä¸€ä¸ªé‡å¤æ¬¡æ•°ï¼Œä»å­—ç¬¦ä¸²æ ˆä¸­å¼¹å‡ºä¸€ä¸ªå­—ç¬¦ä¸²
            num, str := cntStack[len(cntStack)-1], strStack[len(strStack)-1]
            cntStack, strStack = cntStack[:len(cntStack)-1], strStack[:len(strStack)-1]
            // å°†å½“å‰çš„å­—ç¬¦ä¸²é‡å¤æŒ‡å®šçš„æ¬¡æ•°ï¼Œç„¶åä¸ä¸Šä¸€ä¸ªå­—ç¬¦ä¸²åˆå¹¶
            currStr = str + strings.Repeat(currStr, num)
        default:
            currStr += string(v)
        }
    }
    return currStr
}
```

> ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜å‚¨æ•°å­—ï¼Œä¸€ä¸ªå­˜å‚¨å­—ç¬¦ä¸²ï¼Œéå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°æ•°å­—å…¥æ•°å­—æ ˆï¼Œé‡åˆ°å·¦æ‹¬å·å…¥å­—ç¬¦ä¸²æ ˆï¼Œé‡åˆ°å³æ‹¬å·å‡ºæ ˆï¼Œé‡å¤å­—ç¬¦ä¸²ï¼Œæœ€åè¿”å›ç»“æœ

</details>

<details markdown="1">
<summary>739. æ¯æ—¥æ¸©åº¦ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ temperatures ï¼Œè¡¨ç¤ºæ¯å¤©çš„æ¸©åº¦ï¼Œè¿”å›ä¸€ä¸ªæ•°ç»„ answer ï¼Œå…¶ä¸­ answer[i] æ˜¯æŒ‡å¯¹äºç¬¬ i å¤©ï¼Œä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦å‡ºç°åœ¨å‡ å¤©åã€‚ å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚

```golang
func dailyTemperatures(temperatures []int) []int {
    res := make([]int, len(temperatures))
    stack := []int{}
    for i, v := range temperatures {
        for len(stack) > 0 && v > temperatures[stack[len(stack)-1]] {
            // å½“å‰æ¸©åº¦å¤§äºæ ˆé¡¶å…ƒç´ å¯¹åº”çš„æ¸©åº¦æ—¶ï¼Œæ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œè®¡ç®—ç»“æœ
            res[stack[len(stack)-1]] = i - stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, i)
    }
    return res
}
```

> å•è°ƒæ ˆï¼Œéå†æ•°ç»„ï¼Œç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡æ ˆï¼Œæ ˆä¸­å­˜å‚¨çš„æ˜¯ä¸‹æ ‡ï¼Œé‡åˆ°æ¯”æ ˆé¡¶å…ƒç´ å¤§çš„å…ƒç´ ï¼Œå‡ºæ ˆå¹¶è®¡ç®—ç»“æœ

</details>

### å †

<details markdown="1">
<summary>215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ï¼ˆMediumï¼‰</summary>

> ç»™å®šæ•´æ•°æ•°ç»„ nums å’Œæ•´æ•° kï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ k ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚è¯·è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜

```golang
func findKthLargest(nums []int, k int) int {
    lo, hi := 0, len(nums)-1
    for lo < hi {
        pivot := partition(nums, lo, hi)
        switch {
        // k-1 æ˜¯ä¸‹æ ‡ï¼Œmid æ˜¯ä¸‹æ ‡ï¼Œæ‰€ä»¥ k-1 == mid æ—¶ï¼Œæ‰¾åˆ°äº†ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        case k-1 < pivot:
            hi = pivot - 1
        case k-1 > pivot:
            lo = pivot + 1
        default:
            return nums[pivot]
        }
    }
    return nums[lo]
}
// ä¸€æ¬¡åˆ’åˆ†ï¼Œè¿”å›æ¢è½´å…ƒç´ çš„ä¸‹æ ‡ï¼Œæ¢è½´çš„ä½ç½®æ˜¯ç¡®å®šçš„ï¼Œåç»­ä¸å†å˜åŒ–
// æ¢è½´å·¦è¾¹çš„å…ƒç´ éƒ½å¤§äºæ¢è½´ï¼Œå³è¾¹çš„å…ƒç´ éƒ½å°äºæ¢è½´ï¼Œä¸éœ€è¦è€ƒè™‘æ¢è½´ä¸¤ä¾§å…ƒç´ çš„é¡ºåº
func partition(nums []int, lo, hi int) int {
    pivot := nums[lo]
    i, j := lo, hi
    for i < j {
        for i < j && nums[j] <= pivot {
            j--
        }
        nums[i] = nums[j]
        for i < j && nums[i] >= pivot {
            i++
        }
        nums[j] = nums[i]
    }
    nums[i] = pivot
    return i
}
```

> å¿«é€Ÿé€‰æ‹©ï¼Œä½¿ç”¨å¿«é€Ÿæ’åºçš„ partition å‡½æ•°ï¼Œæ ¹æ® pivot çš„ä½ç½®åˆ¤æ–­ k åœ¨å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼Œé€’å½’å¤„ç†
</details>

### è´ªå¿ƒç®—æ³•

<details markdown="1">
<summary>121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå…¶ä¸­ prices[i] æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ä½ åªèƒ½é€‰æ‹©æŸä¸€å¤©ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚

```golang
func maxProfit(prices []int) int {
    var minIndex, bonus int
    for i, p := range prices {
        // é¦–å…ˆåˆ—å‡º profit çš„è®¡ç®—å…¬å¼ï¼Œå½“å‰ä»·æ ¼å‡å»æœ€å°ä»·æ ¼
        profit := p - prices[minIndex]
        if profit > bonus {
            bonus = profit
        } else if profit < 0 {
            // æ›´æ–°æœ€å°ä»·æ ¼çš„ç´¢å¼•
            minIndex = i
        }
    }
    return bonus
}
```
</details>

<details markdown="1">
<summary>55. è·³è·ƒæ¸¸æˆï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä¸‹æ ‡ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ã€‚

```golang
func canJump(nums []int) bool {
    // å®šä¹‰ä¸€ä¸ªå˜é‡ coverï¼Œè¡¨ç¤ºå½“å‰èƒ½å¤Ÿè¦†ç›–çš„æœ€è¿œä½ç½®ï¼Œindex è¡¨ç¤ºæ•°ç»„çš„æœ€åä¸€ä¸ªä¸‹æ ‡
    cover, index := 0, len(nums)-1
    for i := 0; i <= cover; i++ {
        cover = max(cover, i+nums[i])
        // å¦‚æœ cover å¤§äºç­‰äº indexï¼Œè¯´æ˜å¯ä»¥åˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ï¼Œè¿”å› true
        if cover >= index {
            return true
        }
    }
    return false
}
```
</details>

<details markdown="1">
<summary>45. è·³è·ƒæ¸¸æˆ IIï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚ä½ çš„ç›®æ ‡æ˜¯ä½¿ç”¨æœ€å°‘çš„è·³è·ƒæ¬¡æ•°åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚

```golang
func jump(nums []int) int {
    steps, position := 0, len(nums)-1
    for position > 0 {
        for i := 0; i < position; i++ {
            // å¦‚æœå½“å‰ä½ç½®èƒ½å¤Ÿåˆ°è¾¾çš„æœ€è¿œä½ç½®å¤§äºç­‰äº positionï¼Œè¯´æ˜ä»å½“å‰ä½ç½®å¯ä»¥ä¸€æ­¥è·³åˆ°æœ€åä¸€ä¸ªä½ç½®
            if i+nums[i] >= position {
                position = i
                steps++
                break
            }
        }
    }
    return steps
}
```
</details>

<details markdown="1">
<summary>763. åˆ’åˆ†å­—æ¯åŒºé—´ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å¯¹ s çš„å­ä¸²è¿›è¡Œåˆ’åˆ†ï¼Œå¹¶è¿”å›å­ä¸²çš„ä¸ªæ•°ã€‚åˆ’åˆ†è¦å°½å¯èƒ½å¤šçš„å­ä¸²ï¼Œå¹¶ä¸”æ¯ä¸ªå­—æ¯åªèƒ½å‡ºç°åœ¨ä¸€ä¸ªå­ä¸²ä¸­ã€‚å°†åˆ’åˆ†ç»“æœæŒ‰é¡ºåºè¿æ¥ï¼Œå¾—åˆ°çš„å­—ç¬¦ä¸²åº”å½“ä¸åŸå­—ç¬¦ä¸²å®Œå…¨ç›¸åŒã€‚

```golang
func partitionLabels(s string) []int {
    lastIndex := make(map[byte]int)
    for i := 0; i < len(s); i++ {
        lastIndex[s[i]] = i
    }
    var ans []int
    start, end := 0, 0
    // éå†å­—ç¬¦ä¸²ï¼Œend è®°å½•å½“å‰å­ä¸²çš„ç»“æŸä½ç½®
    for i := 0; i < len(s); i++ {
        end = max(end, lastIndex[s[i]])
        // å½“å‰ä½ç½®ç­‰äº end æ—¶ï¼Œè¡¨ç¤ºå½“å‰å­ä¸²ç»“æŸï¼Œå¯ä»¥åˆ’åˆ†
        if i == end {
            ans = append(ans, end-start+1)
            start = end + 1
        }
    }
    return ans
}
```
> è´ªå¿ƒç®—æ³•ï¼Œéå†å­—ç¬¦ä¸²ï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦æœ€åå‡ºç°çš„ä½ç½®ï¼Œéå†å­—ç¬¦ä¸²ï¼Œæ›´æ–°å½“å‰å­ä¸²çš„ç»“æŸä½ç½®ï¼Œå½“å½“å‰ä½ç½®ç­‰äºç»“æŸä½ç½®æ—¶ï¼Œåˆ’åˆ†å­ä¸²

</details>

### åŠ¨æ€è§„åˆ’

<details markdown="1">
<summary>70. çˆ¬æ¥¼æ¢¯ï¼ˆEasyï¼‰</summary>

> å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ

```golang
func climbStairs(n int) int {
    // p:dp[i-2]ï¼Œq:dp[i-1]ï¼Œr:dp[i]
    p, q, r := 0, 0, 1
    for i := 1; i <= n; i++ {
        p = q
        q = r
        r = p + q
    }
    return r
}
```

> åŠ¨æ€è§„åˆ’ï¼Œdp[i] = dp[i-1] + dp[i-2]

</details>

<details markdown="1">
<summary>118. æ¨è¾‰ä¸‰è§’ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° numRowsï¼Œç”Ÿæˆæ¨è¾‰ä¸‰è§’çš„å‰ numRows è¡Œã€‚

```golang
func generate(numRows int) [][]int {
    ans := make([][]int, numRows)
    for i := 0; i < numRows; i++ {
        ans[i] = make([]int, i+1)
        ans[i][0], ans[i][i] = 1, 1
        for j := 1; j < i; j++ {
            ans[i][j] = ans[i-1][j-1] + ans[i-1][j]
        }
    }
    return ans
}
```
</details>

<details markdown="1">
<summary>198. æ‰“å®¶åŠ«èˆï¼ˆMediumï¼‰</summary>

> ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œ å¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚

```golang
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    // å½“æˆ¿é—´æ•°å¤§äºç­‰äº 2
    first, second := nums[0], max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        // first è¡¨ç¤ºå‰ i-1 ä¸ªæˆ¿é—´çš„æœ€å¤§å€¼ï¼Œsecond è¡¨ç¤ºå‰ i ä¸ªæˆ¿é—´çš„æœ€å¤§å€¼
        first, second = second, max(first+nums[i], second)
    }
    return second
}
```
</details>

<details markdown="1">
<summary>279. å®Œå…¨å¹³æ–¹æ•°ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›å’Œä¸º n çš„å®Œå…¨å¹³æ–¹æ•°çš„ æœ€å°‘æ•°é‡ ã€‚å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼ç­‰äºå¦ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹ï¼›æ¢å¥è¯è¯´ï¼Œå…¶å€¼ç­‰äºä¸€ä¸ªæ•´æ•°è‡ªä¹˜çš„ç§¯ã€‚

```golang
func numSquares(n int) int {
    dp := make([]int, n+1)
    for i := 1; i <= n; i++ {
        cnt := math.MaxInt32
        for j := 1; j*j <= i; j++ {
            cnt = min(cnt, dp[i-j*j])
        }
        dp[i] = cnt + 1
    }
    return dp[n]
}
```
</details>

<details markdown="1">
<summary>322. é›¶é’±å…‘æ¢ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ coins ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° amount ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ æœ€å°‘çš„ç¡¬å¸ä¸ªæ•° ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1 ã€‚ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚

```golang
func coinChange(coins []int, amount int) int {
    if amount == 0 {
        return 0
    }
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        // åˆå§‹åŒ–ä¸º amount+1ï¼Œä¸å¯èƒ½å–åˆ°çš„å€¼
        dp[i] = amount + 1
    }
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i >= coin {
                // dp[i-coin]+1ï¼šä½¿ç”¨ä¸€æš coin é¢å€¼çš„ç¡¬å¸ï¼Œç„¶åè®¡ç®—å‰©ä½™é‡‘é¢ i-coin çš„æœ€å°‘ç¡¬å¸æ•°
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == amount+1 {
        return -1
    }
    return dp[amount]
}
```
</details>

<details markdown="1">
<summary>139. å•è¯æ‹†åˆ†ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ wordDict ï¼Œs çš„æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯å°å†™è‹±æ–‡å­—æ¯ã€‚ å¦‚æœå¯ä»¥åˆ©ç”¨ wordDict ä¸­çš„å•è¯æ‹¼æ¥ s ï¼Œåˆ™è¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚

```golang
func wordBreak(s string, wordDict []string) bool {
    set := make(map[string]struct{})
    for _, word := range wordDict {
        set[word] = struct{}{}
    }
    // ans[i] è¡¨ç¤º s[:i] æ˜¯å¦å¯ä»¥æ‹†åˆ†æˆ wordDict ä¸­çš„å•è¯
    ans := make([]bool, len(s)+1)
    ans[0] = true
    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            // å¦‚æœ ans[j] ä¸º true ä¸” s[j:i] åœ¨ wordDict ä¸­ï¼Œåˆ™ ans[i] ä¸º true
            if _, ok := set[s[j:i]]; ok && ans[j] {
                ans[i] = true
                break
            }
        }
    }
    return ans[len(s)]
}
```
</details>

<details markdown="1">
<summary>300. æœ€é•¿é€’å¢å­åºåˆ—ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚

```golang
func lengthOfLIS(nums []int) int {
    var res int
    // dp[i] è¡¨ç¤ºä»¥ nums[i] ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
    dp := make([]int, len(nums))
    // åˆå§‹åŒ– dp æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½è‡³å°‘å¯ä»¥å•ç‹¬æˆä¸ºä¸€ä¸ªå­åºåˆ—
    for i := range dp {
        dp[i] = 1
    }
    for i := range nums {
        for j := range i {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    for _, v := range dp {
        res = max(res, v)
    }
    return res
}
```
</details>

<details markdown="1">
<summary>416. åˆ†å‰²ç­‰å’Œå­é›†ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªåªåŒ…å«æ­£æ•´æ•°çš„éç©ºæ•°ç»„ nums ã€‚è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†ï¼Œä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚

```golang
// å¦‚æœæ•°ç»„çš„å’Œæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆä¸å¯èƒ½åˆ†å‰²æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„å­é›†
// å¦‚æœæ•°ç»„çš„å’Œæ˜¯å¶æ•°ï¼Œé‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆèƒŒåŒ…é—®é¢˜ï¼ŒèƒŒåŒ…å®¹é‡æ˜¯æ•°ç»„å’Œçš„ä¸€åŠ
func canPartition(nums []int) bool {
    var sum int
    for _, num := range nums {
        sum += num
    }
    if sum%2 == 1 {
        return false
    }
    target := sum >> 1
    // dp è¡¨ç¤ºæ˜¯å¦å¯ä»¥ä»æ•°ç»„ä¸­é€‰å–è‹¥å¹²ä¸ªæ•°ï¼Œä½¿å¾—è¿™äº›æ•°çš„å’Œç­‰äº target
    dp := make([]bool, target+1)
    dp[0] = true
    for _, num := range nums {
        for j := target; j >= num; j-- {
            dp[j] = dp[j] || dp[j-num]
        }
    }
    return dp[target]
}
```
</details>

### å¤šç»´åŠ¨æ€è§„åˆ’

<details markdown="1">
<summary>62. ä¸åŒè·¯å¾„ï¼ˆMediumï¼‰</summary>

`dp`

```golang
// dp[j] å­˜å‚¨çš„æ˜¯åˆ°è¾¾å½“å‰è¡Œç¬¬ j åˆ—çš„è·¯å¾„æ•°é‡ã€‚
// dp[j] çš„æ–°å€¼ç­‰äº dp[j]ï¼ˆä¸Šè¾¹çš„è·¯å¾„æ•°é‡, åŒä¸€åˆ—ï¼‰å’Œ dp[j-1]ï¼ˆå·¦è¾¹åˆ—çš„è·¯å¾„æ•°é‡ï¼‰çš„å’Œã€‚
func uniquePaths(m, n int) int {
    dp := make([]int, n)
    // åˆ°è¾¾ç¬¬ä¸€è¡Œçš„ä»»ä½•ä½ç½®åªæœ‰ä¸€ç§èµ°æ³•, æ‰€ä»¥åˆå§‹åŒ–ä¸º 1
    for i := range dp {
        dp[i] = 1
    }
    // ä»ç¬¬äºŒè¡Œå¼€å§‹ï¼Œæ¯ä¸ªä½ç½®çš„èµ°æ³•ç­‰äºå·¦è¾¹ (dp[j-1]) å’Œä¸Šè¾¹ (dp[j]) çš„èµ°æ³•ä¹‹å’Œ
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[j] += dp[j-1]
        }
    }
    return dp[n-1]
}
```

`æ’åˆ—ç»„åˆ`

```golang
func uniquePaths1(m, n int) int {
    return int(new(big.Int).Binomial(int64(m+n-2), int64(m-1)).Int64())
}
```

> æ•°å­¦æ–¹æ³•ï¼Œæ’åˆ—ç»„åˆï¼Œä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ä¸€å…±éœ€è¦èµ° m+n-2 æ­¥ï¼Œå…¶ä¸­ m-1 æ­¥å‘ä¸‹ï¼Œn-1 æ­¥å‘å³ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ C(m+n-2, m-1)

</details>

<details markdown="1">
<summary>64. æœ€å°è·¯å¾„å’Œï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ m x n ç½‘æ ¼ grid ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚

```golang
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([]int, n)
    dp[0] = grid[0][0]
    // ç¬¬ä¸€è¡Œä¸­é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ å¤–ï¼Œæ¯ä¸ªå…ƒç´ çš„è·¯å¾„å’Œç­‰äºå·¦è¾¹çš„è·¯å¾„å’ŒåŠ ä¸Šå½“å‰æ ¼å­çš„æƒé‡
    for i := 1; i < n; i++ {
        dp[i] = dp[i-1] + grid[0][i]
    }
    // ä»ç¬¬äºŒè¡Œå¼€å§‹ï¼Œæ¯ä¸ªå…ƒç´ çš„è·¯å¾„å’Œç­‰äºä¸Šè¾¹å…ƒç´ çš„è·¯å¾„å’Œ (dp[j]) å’Œå·¦è¾¹å…ƒç´ çš„è·¯å¾„å’Œ (dp[j-1]) çš„è¾ƒå°å€¼åŠ ä¸Šå½“å‰æ ¼å­çš„æƒé‡
    for i := 1; i < m; i++ {
        dp[0] += grid[i][0]
        for j := 1; j < n; j++ {
            dp[j] = min(dp[j-1], dp[j]) + grid[i][j]
        }
    }
    return dp[n-1]
}
```
> å’Œç¬¬ 62 é¢˜ç±»ä¼¼ï¼Œä¸è¿‡æ˜¯æ ¼å­åŠ äº†æƒé‡ï¼Œæ±‚æœ€å°è·¯å¾„å’Œ
 
</details>

<details markdown="1">
<summary>5. æœ€é•¿å›æ–‡å­ä¸²ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä»å·¦å‘å³å†™å’Œä»å³å‘å·¦å†™æ˜¯ä¸€æ ·çš„ï¼Œè¿™æ ·çš„å­—ç¬¦ä¸²å°±æ˜¯å›æ–‡ä¸²ã€‚

```golang
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start, end := 0, 0
    for i := 0; i < len(s); i++ {
        // å¯¹åº”å¥‡æ•°é•¿åº¦çš„å›æ–‡ä¸²
        l1, r1 := expandAroundCenter(s, i, i)
        // å¯¹åº”å¶æ•°é•¿åº¦çš„å›æ–‡ä¸²
        l2, r2 := expandAroundCenter(s, i, i+1)
        if r1-l1 > end-start {
            start, end = l1, r1
        }
        if r2-l2 > end-start {
            start, end = l2, r2
        }
    }
    return s[start : end+1]
}
func expandAroundCenter(s string, left, right int) (int, int) {
    // ä»ä¸­å¿ƒå‘ä¸¤è¾¹æ‰©å±•
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    // è¿”å›ç¬¦åˆæ¡ä»¶çš„å­ä¸²çš„å·¦å³ç´¢å¼•, é€†æ“ä½œ left--, right++
    return left + 1, right - 1
}
```
</details>

<details markdown="1">
<summary>1143. æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆMediumï¼‰</summary>

> ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²Â text1 å’ŒÂ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨å…¬å…±å­åºåˆ—ï¼Œè¿”å› 0 ã€‚

> å­åºåˆ—: æ˜¯ç”±åŸå­—ç¬¦ä¸²åˆ é™¤ä¸€äº›(æˆ–ä¸åˆ é™¤)å­—ç¬¦è€Œä¸æ”¹å˜å‰©ä½™å­—ç¬¦ç›¸å¯¹ä½ç½®å½¢æˆçš„æ–°å­—ç¬¦ä¸²

```golang
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    // dp[i][j] è¡¨ç¤º text1[0:i] å’Œ text2[0:j] çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                // å¦‚æœ text1[i-1] == text2[j-1]ï¼Œåˆ™ text1[i-1] å’Œ text2[j-1] å¿…ç„¶åœ¨æœ€é•¿å…¬å…±å­åºåˆ—ä¸­
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                // å¦åˆ™ï¼Œtext1[i-1] å’Œ text2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨æœ€é•¿å…¬å…±å­åºåˆ—ä¸­
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```
</details>

<details markdown="1">
<summary>72. ç¼–è¾‘è·ç¦»ï¼ˆMediumï¼‰</summary>

> ç»™ä½ ä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œè¯·ä½ è®¡ç®—å‡ºå°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•° ã€‚ ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š 1. æ’å…¥ä¸€ä¸ªå­—ç¬¦ 2. åˆ é™¤ä¸€ä¸ªå­—ç¬¦ 3. æ›¿æ¢ä¸€ä¸ªå­—ç¬¦

```golang
func minDistance(word1, word2 string) int {
    m, n := len(word1), len(word2)
    // dp[i][j] è¡¨ç¤º word1[:i] è½¬æ¢æˆ word2[:j] æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•°
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 0; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 0; j <= n; j++ {
        dp[0][j] = j
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // å¦‚æœ word1[i-1] == word2[j-1]ï¼Œåˆ™ä¸éœ€è¦æ“ä½œ
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                // å¦åˆ™ï¼Œå–æ’å…¥ã€åˆ é™¤ã€æ›¿æ¢æ“ä½œçš„æœ€å°å€¼
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
            }
        }
    }
    return dp[m][n]
}
```
</details>

### æŠ€å·§

<details markdown="1">
<summary>136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼ˆEasyï¼‰</summary>

> ç»™ä½ ä¸€ä¸ªéç©ºæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—åªå‡ºç°äº†ä¸€æ¬¡ï¼Œå…¶ä»–çš„æ•°å­—éƒ½å‡ºç°äº†ä¸¤æ¬¡ã€‚æ‰¾å‡ºè¿™ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚

`ä½è¿ç®—`

```golang
func singleNumber(nums []int) int {
    var single int
    for _, num := range nums {
        // å¼‚æˆ–è¿ç®—ï¼Œç›¸åŒçš„æ•°å¼‚æˆ–ç»“æœä¸º0ï¼Œ0å’Œä»»ä½•æ•°å¼‚æˆ–ç»“æœä¸ºä»»ä½•æ•°
        single ^= num
    }
    return single
}
```

`é›†åˆ`

```golang
func singleNumber1(nums []int) int {
    set := make(map[int]struct{})
    for _, v := range nums {
        // å¦‚æœå­—å…¸ä¸­å­˜åœ¨è¯¥å…ƒç´ ï¼Œåˆ™åˆ é™¤ï¼Œå¦åˆ™æ·»åŠ 
        if _, ok := set[v]; ok {
            delete(set, v)
        } else {
            set[v] = struct{}{}
        }
    }
    for k := range set {
        return k
    }
    return -1
}

```
</details>

<details markdown="1">
<summary>169. å¤šæ•°å…ƒç´ ï¼ˆEasyï¼‰</summary>

> ç»™å®šä¸€ä¸ªå¤§å°ä¸º n çš„æ•°ç»„ numsï¼Œè¿”å›å…¶ä¸­çš„å¤šæ•°å…ƒç´ ã€‚å¤šæ•°å…ƒç´ æ˜¯æŒ‡åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°å¤§äº n/2 çš„å…ƒç´ ã€‚å¯ä»¥å‡å®šæ•°ç»„æ˜¯éç©ºçš„ï¼Œå¹¶ä¸”ç»™å®šçš„æ•°ç»„æ€»æ˜¯å­˜åœ¨å¤šæ•°å…ƒç´ ã€‚

`æ‘©å°”æŠ•ç¥¨æ³•`

```golang
func majorityElement(nums []int) int {
    // å®šä¹‰ ä¼—æ•° å’Œ ç»Ÿè®¡æ•°
    var major, cnt int
    for _, num := range nums {
        // å¦‚æœè®¡æ•°æ¸…é›¶åˆ™é‡æ–°é€‰å®šå½“å‰ num ä¸º major
        if cnt == 0 {
            major = num
        }
        // å¦‚æœå½“å‰ num ç­‰äº major åˆ™è®¡æ•°åŠ ä¸€ï¼Œå¦åˆ™å‡ä¸€
        if num == major {
            cnt++
        } else {
            cnt--
        }
    }
    return major
}
```

`å“ˆå¸Œè¡¨`

```golang
func majorityElement1(nums []int) int {
    m := make(map[int]int)
    for _, num := range nums {
        m[num]++
        // å¦‚æœå½“å‰æ•°å­—å‡ºç°æ¬¡æ•°å¤§äº n/2ï¼Œåˆ™æ‰¾åˆ°ä¼—æ•°
        if m[num] > len(nums)/2 {
            return num
        }
    }
    return -1
}
```
</details>